<!DOCTYPE html>
<html lang="zh">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Language" content="zh">
    

    
    <meta name="description" content="数据类型 标量类型（scalar） 整数类型 除了Byte，其余所有的字面量都可以使用类型后缀，比如57u8，代表一个使用了u8类型的整数57。同">
    <meta name="keywords" content="rust">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="rust基础笔记"/>
<meta name="twitter:description" content="数据类型 标量类型（scalar） 整数类型 除了Byte，其余所有的字面量都可以使用类型后缀，比如57u8，代表一个使用了u8类型的整数57。同"/>

    <meta property="og:title" content="rust基础笔记" />
<meta property="og:description" content="数据类型 标量类型（scalar） 整数类型 除了Byte，其余所有的字面量都可以使用类型后缀，比如57u8，代表一个使用了u8类型的整数57。同" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://stong1994.github.io/note/rust/base/" /><meta property="article:section" content="internet" />
<meta property="article:published_time" content="2022-06-04T14:35:00+08:00" />
<meta property="article:modified_time" content="2022-06-04T14:35:00+08:00" />



    <title>
  rust基础笔记 · 北人
</title>

    
      <link rel="canonical" href="https://stong1994.github.io/note/rust/base/">
    

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700&display=swap" rel="stylesheet">
    <link rel="preload" href="/fonts/forkawesome-webfont.woff2?v=1.1.7" as="font" type="font/woff2" crossorigin>

    
      
      
      <link rel="stylesheet" href="/css/coder.min.5317d5aa4161466b8ec88da2b36cacd596a0fdc1cc6a986e05f9b413df8ad2d3.css" integrity="sha256-UxfVqkFhRmuOyI2is2ys1Zag/cHMaphuBfm0E9&#43;K0tM=" crossorigin="anonymous" media="screen" />
    

    

    
      
        
        
        <link rel="stylesheet" href="/css/coder-dark.min.126ad3988d46bdae6217a11105b53c9662bca05f39d42d3c0fb366919d334620.css" integrity="sha256-EmrTmI1Gva5iF6ERBbU8lmK8oF851C08D7NmkZ0zRiA=" crossorigin="anonymous" media="screen" />
      
    

    

    

    <link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

    <link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

    
      <script defer src="https://twemoji.maxcdn.com/v/13.0.1/twemoji.min.js"
        integrity="sha384-5f4X0lBluNY/Ib4VhGx0Pf6iDCF99VGXJIyYy7dDLY5QlEd7Ap0hICSSZA1XYbc4" crossorigin="anonymous"></script>
    

    <meta name="generator" content="Hugo 0.101.0" />
  </head>

  
  
    
  
  <body class="colorscheme-auto"
        onload=" twemoji.parse(document.body); "
  >
    
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      北人
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/internet/">计算机与互联网</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/cloudnative/">云原生</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/web3/">区块链&amp;web3</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/other/">杂谈</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/mental_model/">心智模型</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/about/">关于</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


      <div class="content">
        
    <div id="toc" class="well col-md-4 col-sm-6">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#数据类型">数据类型</a>
      <ul>
        <li><a href="#标量类型scalar">标量类型（scalar）</a></li>
        <li><a href="#复合类型compound">复合类型（compound）</a></li>
      </ul>
    </li>
    <li><a href="#函数">函数</a>
      <ul>
        <li><a href="#函数的返回值">函数的返回值</a></li>
      </ul>
    </li>
    <li><a href="#注释">注释</a></li>
    <li><a href="#变量">变量</a>
      <ul>
        <li><a href="#shadow">shadow</a></li>
      </ul>
    </li>
    <li><a href="#常量">常量</a></li>
    <li><a href="#字符串">字符串</a>
      <ul>
        <li><a href="#字符串字面量">字符串字面量</a></li>
        <li><a href="#字符串类型">字符串类型</a></li>
      </ul>
    </li>
    <li><a href="#所有权">所有权</a>
      <ul>
        <li><a href="#引用借用">引用(借用)</a></li>
        <li><a href="#解引用">解引用</a></li>
        <li><a href="#切片">切片</a></li>
      </ul>
    </li>
    <li><a href="#结构体">结构体</a>
      <ul>
        <li><a href="#方法">方法</a></li>
        <li><a href="#关联函数">关联函数</a></li>
      </ul>
    </li>
    <li><a href="#枚举">枚举</a>
      <ul>
        <li><a href="#option枚举">Option枚举</a></li>
        <li><a href="#result枚举">Result枚举</a></li>
      </ul>
    </li>
    <li><a href="#流程控制">流程控制</a>
      <ul>
        <li><a href="#if-else">if-else</a></li>
        <li><a href="#loop">loop</a></li>
        <li><a href="#while">while</a></li>
        <li><a href="#for">for</a></li>
        <li><a href="#match">match</a></li>
      </ul>
    </li>
    <li><a href="#动态数组">动态数组</a></li>
    <li><a href="#字符串-1">字符串</a></li>
    <li><a href="#哈希表">哈希表</a></li>
    <li><a href="#泛型">泛型</a></li>
    <li><a href="#关联类型">关联类型</a></li>
    <li><a href="#trait">trait</a>
      <ul>
        <li><a href="#debug-trait">Debug trait</a></li>
        <li><a href="#copy-trait">Copy trait</a></li>
        <li><a href="#clone-trait">Clone trait</a></li>
        <li><a href="#display-trait">Display trait</a></li>
        <li><a href="#fn-trait"><strong>Fn trait</strong></a></li>
        <li><a href="#fnmut-trait"><strong>FnMut trait</strong></a></li>
        <li><a href="#fnonce-trait"><strong>FnOnce trait</strong></a></li>
      </ul>
    </li>
    <li><a href="#引用中的生命周期">引用中的生命周期</a>
      <ul>
        <li><a href="#计算生命周期的三个原则">计算生命周期的三个原则</a></li>
        <li><a href="#静态生命周期">静态生命周期</a></li>
      </ul>
    </li>
    <li><a href="#迭代器">迭代器</a></li>
    <li><a href="#错误处理">错误处理</a></li>
    <li><a href="#模块">模块</a>
      <ul>
        <li><a href="#重新导入-pub-use">重新导入-pub use</a></li>
        <li><a href="#文件模块"><strong>文件模块</strong></a></li>
        <li><a href="#目录模块"><strong>目录模块</strong></a></li>
      </ul>
    </li>
    <li><a href="#闭包">闭包</a></li>
    <li><a href="#智能指针">智能指针</a>
      <ul>
        <li><a href="#boxt"><code>Box&lt;T&gt;</code></a></li>
        <li><a href="#rct"><code>Rc&lt;T&gt;</code></a></li>
        <li><a href="#refcellt"><code>RefCell&lt;T&gt;</code></a></li>
        <li><a href="#weakt"><code>Weak&lt;T&gt;</code></a></li>
        <li><a href="#结合rc和refcell实现可变链表">结合Rc和RefCell实现可变链表</a></li>
      </ul>
    </li>
    <li><a href="#并发">并发</a>
      <ul>
        <li><a href="#线程">线程</a></li>
        <li><a href="#锁原子">锁+原子</a></li>
      </ul>
    </li>
    <li><a href="#模式">模式</a>
      <ul>
        <li><a href="#范围模式">范围模式</a></li>
        <li><a href="#match中的模式">match中的模式</a></li>
        <li><a href="#解构赋值">解构赋值</a></li>
        <li><a href="#忽略值">忽略值</a></li>
      </ul>
    </li>
    <li><a href="#版本控制">版本控制</a></li>
    <li><a href="#其他">其他</a>
      <ul>
        <li><a href="#doc">doc</a></li>
      </ul>
    </li>
    <li><a href="#资料">资料</a></li>
  </ul>
</nav>
    </div>
  <section class="container page">
  <article>
    <header>
      <h1>rust基础笔记</h1>
    </header>

    <h2 id="数据类型">数据类型</h2>
<h3 id="标量类型scalar">标量类型（scalar）</h3>
<h4 id="整数类型">整数类型</h4>
<p><img src="https://raw.githubusercontent.com/stong1994/images/master/picgo/202209040012877.png" alt=""></p>
<p>除了Byte，其余所有的字面量都可以使用类型后缀，比如57u8，代表一个使用了u8类型的整数57。同时你也可以使用_作为分隔符以方便读数，比如1_000。</p>
<p><img src="https://raw.githubusercontent.com/stong1994/images/master/picgo/202209040102726.png" alt=""></p>
<h4 id="浮点类型">浮点类型</h4>
<p>浮点类型有两种：f32和f64，它们分别占用32位和64位空间。</p>
<h4 id="布尔类型">布尔类型</h4>
<p>布尔类型只有两种值：true和false。</p>
<p>注意：单个布尔类型的值占据单个字节的空间大小</p>
<h4 id="字符类型">字符类型</h4>
<p>在Rust中，char类型被用于描述语言中最基础的单个字符。下面的代码展示了它的使用方式，但需要注意的是，char类型使用单引号指定，而不同于字符串使用双引号指定。</p>
<h3 id="复合类型compound">复合类型（compound）</h3>
<h4 id="元组">元组</h4>
<p>元组是一种相当常见的复合类型，它可以将其他不同类型的多个值组合进一个复合类型中。元组还拥有一个固定的长度：你无法在声明结束后增加或减少其中的元素数量.</p>
<p>两种获取元组内元素值的方式：</p>
<ol>
<li>
<p>通过索引并使用点号（.）来访问元组中的值</p>
</li>
<li>
<p>模式匹配来解构元组</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> tup = (<span style="color:#ff0;font-weight:bold">1</span>, <span style="color:#ff0;font-weight:bold">1.0</span>, <span style="color:#0ff;font-weight:bold">&#39;1&#39;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> (x, y, _) = tup;
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;The value of x is: {}&#34;</span>, x);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;The value of y is: {}&#34;</span>, y);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;The value of z is: {}&#34;</span>, tup.<span style="color:#ff0;font-weight:bold">2</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="数组类型">数组类型</h4>
<p>与元组不同，数组中的每一个元素都必须是相同的类型。Rust中的数组拥有固定的长度，一旦声明就再也不能随意更改大小。</p>
<p>为了写出数组的类型，你需要使用一对方括号，并在方括号中填写数组内所有元素的类型、一个分号及数组内元素的数量，如下所示：
<code>let a: [i32; 5] = [1, 2, 3, 4, 5];</code></p>
<p>“即假如你想要创建一个含有相同元素的数组，那么你可以在方括号中指定元素的值，并接着填入一个分号及数组的长度，如下所示：
<code>let a = [3; 5]；</code>
以a命名的数组将会拥有5个元素，而这些元素全部拥有相同的初始值3。这一写法等价于<code>let a = [3, 3, 3, 3, 3];</code>，但却更加精简。”</p>
<h2 id="函数">函数</h2>
<p>Rust代码使用蛇形命名法（snake case）来作为规范函数和变量名称的风格。蛇形命名法只使用小写的字母进行命名，并以下画线分隔单词。</p>
<h3 id="函数的返回值">函数的返回值</h3>
<p>函数可以向调用它的代码返回值。虽然你不用为这个返回值命名，但需要在箭头符号（-&gt;）的后面声明它的类型。在Rust中，函数的返回值等同于函数体最后一个表达式的值。你可以使用return关键字并指定一个值来提前从函数中返回，但大多数函数都隐式地返回了最后的表达式。</p>
<p>返回值只能有一个，需要返回多个可以使用元组，如果是数据+错误的返回，可以使用Option。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> rst = one();
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, rst);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> one() -&gt;<span style="color:#fff;font-weight:bold">i32</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="注释">注释</h2>
<p>// 行注释</p>
<p>//！ 内部行文档注释</p>
<p>/// 外部行文档注释</p>
<p><code>/*...*/</code>块注释</p>
<p><code>/*!...*/</code>内部块文档注释</p>
<p><code>/**...*/</code>部块文档注释</p>
<h2 id="变量">变量</h2>
<p>在Rust中，变量都是默认不可变的。</p>
<p>可变变量需要声明mut，如<code>let mut a = 10;</code></p>
<h3 id="shadow">shadow</h3>
<p>Rust允许使用同名的新变量guess来隐藏（shadow）旧变量的值。这一特性通常被用在需要转换值类型的场景中.</p>
<blockquote>
<p>在同一个作用域中，新的同名变量可以是不同的类型，避免了amount_str这种业务+类型的名称定义。</p>
</blockquote>
<h2 id="常量">常量</h2>
<p>在Rust程序中，我们约定俗成地使用以下画线分隔的全大写字母来命名一个常量，并在数值中插入下画线来提高可读性。</p>
<p>如<code>const MAX_POINTS: u32 = 100_000;</code></p>
<h2 id="字符串">字符串</h2>
<h3 id="字符串字面量">字符串字面量</h3>
<p>固定大小的字符串，一旦声明则不可改变。存储在栈中。</p>
<h3 id="字符串类型">字符串类型</h3>
<p>大小不固定、可变的字符串。存储在堆中。</p>
<p>字符串类型的底层由三个属性构成：</p>
<ul>
<li>长度</li>
<li>容量</li>
<li>数据地址指针</li>
</ul>
<p>同golang中的slice一模一样。</p>
<p>当字符串类型的值被赋值给另外一个字符串类型的值时，底层数据地址指针相同（同golang中的slice,即浅拷贝）,但由于rust的内存机制，同一个地址不能被两个变量使用，因此会报错。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> s = <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> s2 = s;
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}, {}&#34;</span>, s, s2);
</span></span><span style="display:flex;"><span>}	
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 报错内容：
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// error[E0382]: borrow of moved value: `s
</span></span></span></code></pre></div><p>此时需要深度拷贝数据——即移动（move）数据。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> s = <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> s2 = s.clone();
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}, {}&#34;</span>, s, s2);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="所有权">所有权</h2>
<p>三个原则：</p>
<p>• Rust中的每一个值都有一个对应的变量作为它的所有者。
• 在同一时间内，值有且仅有一个所有者。
• 当所有者离开自己的作用域时，它持有的值就会被释放掉。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> s = <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;hello&#34;</span>); <span style="color:#007f7f">// 变量s进入作用域
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    
</span></span><span style="display:flex;"><span>    abc(s); <span style="color:#007f7f">// s被移动到abc中，在当前作用域中无效；同时s2进入作用域
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> x = <span style="color:#ff0;font-weight:bold">5</span>; <span style="color:#007f7f">// 变量x进入作用域
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    
</span></span><span style="display:flex;"><span>    def(x); <span style="color:#007f7f">// x是i32类型，是Copy的，因此x仍旧有效；同时 x2进入作用域
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    
</span></span><span style="display:flex;"><span>} <span style="color:#007f7f">// x 先离开作用域，然后是x。因为s的值已经发生了移动，因此无事发生。
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> abc(s: <span style="color:#fff;font-weight:bold">String</span>) { <span style="color:#007f7f">// s进入作用域
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, s)
</span></span><span style="display:flex;"><span>} <span style="color:#007f7f">// s离开作用域，自动调用drop函数进行销毁
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> def(x: <span style="color:#fff;font-weight:bold">i32</span>) { <span style="color:#007f7f">// x进入作用域
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, x)
</span></span><span style="display:flex;"><span>} <span style="color:#007f7f">// x离开作用域，无事发生
</span></span></span></code></pre></div><h3 id="引用借用">引用(借用)</h3>
<p>所有权则规定了每个值有且只有一个所有者，决定了在哪里和何时释放内存。</p>
<p>引用是一种机制，让程序在不移动数据所有权的情况下访问和操作数据。</p>
<p>引用表现为指向变量的指针，可以把引用看成是一个指针地址。</p>
<p>借用则是创建了一个引用，并为这个引用赋予操作权限。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">mut</span> a = <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;hello&#34;</span>); <span style="color:#007f7f">// 对于变量a, 指针地址为&amp;a，即引用为&amp;a
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">let</span> b = &amp;<span style="color:#fff;font-weight:bold">mut</span> a; <span style="color:#007f7f">// b借用了a的引用，权限是可编辑。&amp;表示引用,mut表示权限为可编辑
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">mut</span> a = <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>{ <span style="color:#007f7f">// b是一个引用，具备访问和修改a的值的权限。但a仍是数据所有权的所有者
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">let</span> b = &amp;<span style="color:#fff;font-weight:bold">mut</span> a;
</span></span><span style="display:flex;"><span>} <span style="color:#007f7f">// b被释放
</span></span></span></code></pre></div><h3 id="解引用">解引用</h3>
<p>有引用就会有解引用，解引用之后就可以对原数据进行修改。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">mut</span> x = <span style="color:#ff0;font-weight:bold">42</span>;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> z = &amp;<span style="color:#fff;font-weight:bold">mut</span> x; <span style="color:#007f7f">// 创建一个可变引用z指向x
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>println!(<span style="color:#0ff;font-weight:bold">&#34;x = {}&#34;</span>, z); <span style="color:#007f7f">// 输出x当前的值：42
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>*z += <span style="color:#ff0;font-weight:bold">1</span>; <span style="color:#007f7f">// 使用*z来修改x的值
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>println!(<span style="color:#0ff;font-weight:bold">&#34;x = {}&#34;</span>, z); <span style="color:#007f7f">// 输出x当前的值：43
</span></span></span></code></pre></div><p>引用特征：</p>
<ul>
<li>在任何一段给定的时间里，你要么只能拥有一个<strong>可变引用</strong>，要么只能拥有任意数量的<strong>不可变引用</strong>。</li>
<li>引用总是有效的：在 Rust 中使用引用（指针）访问数据时，Rust 能够在编译时检查出数据是否有效，从而避免了悬空指针和空指针引用问题</li>
</ul>
<h4 id="可变引用">可变引用</h4>
<p>即可以修改引用的值。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">mut</span> s = <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    abc(&amp;<span style="color:#fff;font-weight:bold">mut</span> s); 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> abc(s: <span style="color:#fff;font-weight:bold">&amp;</span>mut <span style="color:#fff;font-weight:bold">String</span>) {
</span></span><span style="display:flex;"><span>    s.push_str(<span style="color:#0ff;font-weight:bold">&#34; world&#34;</span>);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, s)
</span></span><span style="display:flex;"><span>} 
</span></span></code></pre></div><h4 id="不可变引用">不可变引用</h4>
<p>即不可以修改引用的值。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> s = <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    abc(&amp;s); 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> abc(s: <span style="color:#fff;font-weight:bold">&amp;</span><span style="color:#fff;font-weight:bold">String</span>) {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, s)
</span></span><span style="display:flex;"><span>} 
</span></span></code></pre></div><h3 id="切片">切片</h3>
<blockquote>
<p>切片允许我们引用集合中某一段连续的元素序列，而不是整个集合（类比golang中切片就是对底层数组中的某段连续元素序列的引用）。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> s = <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> s2 = &amp;s[<span style="color:#ff0;font-weight:bold">1</span>..<span style="color:#ff0;font-weight:bold">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> s3 = &amp;s[..<span style="color:#ff0;font-weight:bold">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> s4 = &amp;s[<span style="color:#ff0;font-weight:bold">1</span>..];
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> s5 = &amp;s[..];
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, s2);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, s3);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, s4);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, s5);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// output
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// el
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// hel
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// ello
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// hello
</span></span></span></code></pre></div><p><strong>字符串字面量就是切片</strong></p>
<h2 id="结构体">结构体</h2>
<p>知识点：</p>
<ol>
<li><strong>字段初始化简写</strong></li>
<li><strong>根据已有结构体覆盖未定义字段</strong></li>
<li><strong>一旦实例可变，那么实例中的所有字段都将是可变的。Rust不允许我们单独声明某一部分字段的可变性。</strong></li>
<li><strong>元组结构体</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#[derive(Debug)]</span> <span style="color:#007f7f">// “添加注解来派生Debug trait，并使用调试格式打印出Rectangle实例”
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">struct</span> User {
</span></span><span style="display:flex;"><span>    name: <span style="color:#fff;font-weight:bold">String</span>,
</span></span><span style="display:flex;"><span>    email: <span style="color:#fff;font-weight:bold">String</span>,
</span></span><span style="display:flex;"><span>    age: <span style="color:#fff;font-weight:bold">u8</span>,
</span></span><span style="display:flex;"><span>    active: <span style="color:#fff;font-weight:bold">bool</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> Color(<span style="color:#fff;font-weight:bold">i8</span>, <span style="color:#fff;font-weight:bold">i8</span>, <span style="color:#fff;font-weight:bold">i8</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> u = User {
</span></span><span style="display:flex;"><span>        name: <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;alice&#34;</span>),
</span></span><span style="display:flex;"><span>        email: <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;alice@outlook.com&#34;</span>),
</span></span><span style="display:flex;"><span>        age: <span style="color:#ff0;font-weight:bold">1</span>,
</span></span><span style="display:flex;"><span>        active: true,
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, u);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> u2 = build_user(<span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;bob@outlook.com&#34;</span>), <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;bob&#34;</span>));
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, u2);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> u3 = build_user(<span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;chris@outlook.com&#34;</span>), <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;chris&#34;</span>));
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, u3);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> u4 = User{
</span></span><span style="display:flex;"><span>        name: <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;david&#34;</span>),
</span></span><span style="display:flex;"><span>        email: <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;david@outlook.com&#34;</span>),
</span></span><span style="display:flex;"><span>        ..u3 <span style="color:#007f7f">// 根据已有结构体覆盖未定义字段
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    };
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, u4);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> white = Color(<span style="color:#ff0;font-weight:bold">0</span>, <span style="color:#ff0;font-weight:bold">0</span>, <span style="color:#ff0;font-weight:bold">0</span>);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, white);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> build_user(email: <span style="color:#fff;font-weight:bold">String</span>, name: <span style="color:#fff;font-weight:bold">String</span>) -&gt; User {
</span></span><span style="display:flex;"><span>    User{
</span></span><span style="display:flex;"><span>        name: name,
</span></span><span style="display:flex;"><span>        email: email,
</span></span><span style="display:flex;"><span>        age: <span style="color:#ff0;font-weight:bold">1</span>,
</span></span><span style="display:flex;"><span>        active: true,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> build_user2(email: <span style="color:#fff;font-weight:bold">String</span>, name: <span style="color:#fff;font-weight:bold">String</span>) -&gt; User {
</span></span><span style="display:flex;"><span>    User{
</span></span><span style="display:flex;"><span>        name, <span style="color:#007f7f">// 字段初始化简写
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        email,
</span></span><span style="display:flex;"><span>        age: <span style="color:#ff0;font-weight:bold">1</span>,
</span></span><span style="display:flex;"><span>        active: true,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="方法">方法</h3>
<ol>
<li>第一个参数永远是self。</li>
<li>隐式转换：当你使用object.something()调用方法时，Rust会自动为调用者object添加&amp;、&amp;mut或*，以使其能够符合方法的签名。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#[derive(Debug)]</span> <span style="color:#007f7f">// “添加注解来派生Debug trait，并使用调试格式打印出Rectangle实例”
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">struct</span> User {
</span></span><span style="display:flex;"><span>    name: <span style="color:#fff;font-weight:bold">String</span>,
</span></span><span style="display:flex;"><span>    email: <span style="color:#fff;font-weight:bold">String</span>,
</span></span><span style="display:flex;"><span>    age: <span style="color:#fff;font-weight:bold">u8</span>,
</span></span><span style="display:flex;"><span>    active: <span style="color:#fff;font-weight:bold">bool</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">impl</span> User {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">fn</span> get_name(self) -&gt; <span style="color:#fff;font-weight:bold">String</span> {
</span></span><span style="display:flex;"><span>        self.name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> u = User {
</span></span><span style="display:flex;"><span>        name: <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;alice&#34;</span>),
</span></span><span style="display:flex;"><span>        email: <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;alice@outlook.com&#34;</span>),
</span></span><span style="display:flex;"><span>        age: <span style="color:#ff0;font-weight:bold">1</span>,
</span></span><span style="display:flex;"><span>        active: true,
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> name = u.get_name();
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, name);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="关联函数">关联函数</h3>
<ol>
<li>不接收self的方法。</li>
<li>常用来构造结构体。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#[derive(Debug)]</span> <span style="color:#007f7f">// “添加注解来派生Debug trait，并使用调试格式打印出Rectangle实例”
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">struct</span> User {
</span></span><span style="display:flex;"><span>    name: <span style="color:#fff;font-weight:bold">String</span>,
</span></span><span style="display:flex;"><span>    email: <span style="color:#fff;font-weight:bold">String</span>,
</span></span><span style="display:flex;"><span>    age: <span style="color:#fff;font-weight:bold">u8</span>,
</span></span><span style="display:flex;"><span>    active: <span style="color:#fff;font-weight:bold">bool</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">impl</span> User {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">fn</span> default_user(name: <span style="color:#fff;font-weight:bold">String</span>) -&gt; User {
</span></span><span style="display:flex;"><span>        User{
</span></span><span style="display:flex;"><span>            name,
</span></span><span style="display:flex;"><span>            email: <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;&#34;</span>),
</span></span><span style="display:flex;"><span>            age: <span style="color:#ff0;font-weight:bold">0</span>,
</span></span><span style="display:flex;"><span>            active: false,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">fn</span> get_name(self) -&gt; <span style="color:#fff;font-weight:bold">String</span> {
</span></span><span style="display:flex;"><span>        self.name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> u = User::default_user(<span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;alice&#34;</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> name = u.get_name();
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, name);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="枚举">枚举</h2>
<ol>
<li>将同一类数据定义为同一个枚举类型。注意：”同一类数据“可以是不同类型，可以关联不同类型的数据。</li>
<li>可以通过impl来定义枚举的方法。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#[derive(Debug)]</span> <span style="color:#007f7f">// “添加注解来派生Debug trait，并使用调试格式打印出Rectangle实例”
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">struct</span> Emp {
</span></span><span style="display:flex;"><span>    id: <span style="color:#fff;font-weight:bold">String</span>,
</span></span><span style="display:flex;"><span>    name: <span style="color:#fff;font-weight:bold">String</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">enum</span> User {
</span></span><span style="display:flex;"><span>    Vistor(<span style="color:#fff;font-weight:bold">String</span>), <span style="color:#007f7f">// 游客, 关联数据为ip字符串
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    Employee(Emp), <span style="color:#007f7f">// 员工, 关联数据为Emp结构体
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    Admin(<span style="color:#fff;font-weight:bold">i32</span>), <span style="color:#007f7f">// 管理员，关联数据为id
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">impl</span> User {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">fn</span> say_hi(self) {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#0ff;font-weight:bold">&#34;hi&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> user = User::Vistor(<span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;127.0.0.1&#34;</span>));
</span></span><span style="display:flex;"><span>    user.say_hi();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="option枚举">Option枚举</h3>
<ol>
<li>内置于标准库</li>
<li>rust中没有空值，但是可以通过Option枚举来实现</li>
<li>假如我们使用了None而不是Some变体来进行赋值，那么我们需要明确地告知Rust这个<code>Option&lt;T&gt;</code>的具体类型。这是因为单独的None变体值与持有数据的Some变体不一样，编译器无法根据这些信息来正确推导出值的完整类型</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#007f7f">// 内置库中的样子
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">enum</span> <span style="color:#fff;font-weight:bold">Option</span>&lt;T&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">Some</span>(T),
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">None</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> one = <span style="color:#fff;font-weight:bold">Some</span>(<span style="color:#ff0;font-weight:bold">1</span>); <span style="color:#007f7f">// 内置Option，不用引用库，也不用这样Option::Some(1)
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">let</span> a = <span style="color:#fff;font-weight:bold">Some</span>(<span style="color:#0ff;font-weight:bold">b&#39;a&#39;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> none: <span style="color:#fff;font-weight:bold">Option</span>&lt;<span style="color:#fff;font-weight:bold">i32</span>&gt; = <span style="color:#fff;font-weight:bold">None</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="result枚举">Result枚举</h3>
<ol>
<li>内置于标准库</li>
<li>常用于结果返回——Ok代表正常，Err代表发生错误</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">use</span> std::fs::File;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> f = File::open(<span style="color:#0ff;font-weight:bold">&#34;hello.txt&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> f = <span style="color:#fff;font-weight:bold">match</span> f {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">Ok</span>(file) =&gt; file,
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">Err</span>(error) =&gt; {
</span></span><span style="display:flex;"><span>            panic!(<span style="color:#0ff;font-weight:bold">&#34;There was a problem opening the file: {:?}&#34;</span>, error)
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="流程控制">流程控制</h2>
<h3 id="if-else">if-else</h3>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> a = <span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> a == <span style="color:#ff0;font-weight:bold">0</span> {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#0ff;font-weight:bold">&#34;0&#34;</span>);
</span></span><span style="display:flex;"><span>    } <span style="color:#fff;font-weight:bold">else</span> <span style="color:#fff;font-weight:bold">if</span> a == <span style="color:#ff0;font-weight:bold">1</span> {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#0ff;font-weight:bold">&#34;1&#34;</span>)
</span></span><span style="display:flex;"><span>    } <span style="color:#fff;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#0ff;font-weight:bold">&#34;2&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>if是一个表达式，所以我们可以在let语句的右侧使用它来生成一个值.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> a = <span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> b = <span style="color:#fff;font-weight:bold">if</span> a == <span style="color:#ff0;font-weight:bold">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff0;font-weight:bold">10</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#fff;font-weight:bold">else</span> <span style="color:#fff;font-weight:bold">if</span> a == <span style="color:#ff0;font-weight:bold">1</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff0;font-weight:bold">11</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#fff;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff0;font-weight:bold">12</span>
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, b);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="loop">loop</h3>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">mut</span> n = <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">loop</span> {
</span></span><span style="display:flex;"><span>        n += <span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span> n == <span style="color:#ff0;font-weight:bold">10</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, n)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>loop同样是表达式，因此可以使用loop来生成一个值。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">mut</span> n = <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> n2 = <span style="color:#fff;font-weight:bold">loop</span> {
</span></span><span style="display:flex;"><span>        n += <span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span> n == <span style="color:#ff0;font-weight:bold">10</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">break</span> n*<span style="color:#ff0;font-weight:bold">2</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}, {}&#34;</span>, n, n2);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="while">while</h3>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>fn main() {
</span></span><span style="display:flex;"><span>    let mut n = 10;
</span></span><span style="display:flex;"><span>    while n != 3 {
</span></span><span style="display:flex;"><span>        println!(&#34;{}&#34;, n);
</span></span><span style="display:flex;"><span>        n -= 1;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    println!(&#34;end&#34;);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="for">for</h3>
<p>相比while，for提供了更便利、安全的迭代器。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> arr = [<span style="color:#ff0;font-weight:bold">1</span>,<span style="color:#ff0;font-weight:bold">2</span>,<span style="color:#ff0;font-weight:bold">3</span>,<span style="color:#ff0;font-weight:bold">4</span>,<span style="color:#ff0;font-weight:bold">5</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> n <span style="color:#fff;font-weight:bold">in</span> arr.iter() {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, n)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>将数组转为元组进行遍历。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> arr = [<span style="color:#ff0;font-weight:bold">1</span>,<span style="color:#ff0;font-weight:bold">2</span>,<span style="color:#ff0;font-weight:bold">3</span>,<span style="color:#ff0;font-weight:bold">4</span>,<span style="color:#ff0;font-weight:bold">5</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (n, &amp;item) <span style="color:#fff;font-weight:bold">in</span> arr.iter().enumerate() {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#0ff;font-weight:bold">&#34;{}, {}&#34;</span>, n, &amp;item)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>翻转遍历：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> n <span style="color:#fff;font-weight:bold">in</span> (<span style="color:#ff0;font-weight:bold">1</span>..<span style="color:#ff0;font-weight:bold">6</span>).rev() {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, n)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="match">match</h3>
<ol>
<li>必须穷举所有可能</li>
<li>可以使用通配符_来过滤未穷举的可能</li>
<li>if let提供了对单个条件筛选的能力</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">enum</span> Grade {
</span></span><span style="display:flex;"><span>    ZERO,
</span></span><span style="display:flex;"><span>    DISAPPOINT,
</span></span><span style="display:flex;"><span>    ORDINARY,
</span></span><span style="display:flex;"><span>    EXCELLENT,
</span></span><span style="display:flex;"><span>    PERFECT,
</span></span><span style="display:flex;"><span>    NOT_POSSIBLE,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> msg = grade_msg(Grade::ZERO);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, msg);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> zero = <span style="color:#fff;font-weight:bold">Some</span>(<span style="color:#ff0;font-weight:bold">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> <span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">Some</span>(<span style="color:#ff0;font-weight:bold">100</span>) = zero {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#0ff;font-weight:bold">&#34;oh my god!&#34;</span>);
</span></span><span style="display:flex;"><span>    }<span style="color:#fff;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#0ff;font-weight:bold">&#34;you are kidding&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> grade_msg(grade: Grade) -&gt; <span style="color:#fff;font-weight:bold">String</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">match</span> grade {
</span></span><span style="display:flex;"><span>        Grade::PERFECT =&gt; <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;perfect!&#34;</span>),
</span></span><span style="display:flex;"><span>        Grade::EXCELLENT =&gt; <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;good!&#34;</span>),
</span></span><span style="display:flex;"><span>        Grade::ORDINARY =&gt; <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;common on!&#34;</span>),
</span></span><span style="display:flex;"><span>        Grade::DISAPPOINT =&gt; <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;fighting!&#34;</span>),
</span></span><span style="display:flex;"><span>        Grade::ZERO =&gt; {
</span></span><span style="display:flex;"><span>            println!(<span style="color:#0ff;font-weight:bold">&#34;what fuck!&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;what&#39;s wrong with you!&#34;</span>)
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        _ =&gt; <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;impossible&#34;</span>),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="动态数组">动态数组</h2>
<ol>
<li>数组中只能存储同一类型的元素</li>
<li>当需要存储不同类型的元素时，可以将其定义为同一种枚举类型</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> arr1: <span style="color:#fff;font-weight:bold">Vec</span>&lt;<span style="color:#fff;font-weight:bold">i32</span>&gt; = <span style="color:#fff;font-weight:bold">Vec</span>::new(); <span style="color:#007f7f">// []
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">mut</span> arr2 = vec![<span style="color:#ff0;font-weight:bold">1</span>,<span style="color:#ff0;font-weight:bold">2</span>,<span style="color:#ff0;font-weight:bold">3</span>]; <span style="color:#007f7f">// [1, 2, 3]
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">let</span> arr3 = vec!([<span style="color:#ff0;font-weight:bold">1</span>,<span style="color:#ff0;font-weight:bold">2</span>,<span style="color:#ff0;font-weight:bold">3</span>]); <span style="color:#007f7f">// [[1, 2, 3]]
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}, {:?}, {:?}&#34;</span>, arr1, arr2, arr3);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 添加
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    arr2.push(<span style="color:#ff0;font-weight:bold">4</span>); <span style="color:#007f7f">// [1, 2, 3, 4]
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, arr2);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 两种读取
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">let</span> two: <span style="color:#fff;font-weight:bold">&amp;</span><span style="color:#fff;font-weight:bold">i32</span> = &amp;arr2[<span style="color:#ff0;font-weight:bold">1</span>]; <span style="color:#007f7f">// 2，数组越界会panic
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, two);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">match</span> arr2.get(<span style="color:#ff0;font-weight:bold">1</span>) { <span style="color:#007f7f">// get方法返回Option&lt;&amp;T&gt;类型，数组越界会返回None
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">Some</span>(two) =&gt; println!(<span style="color:#0ff;font-weight:bold">&#34;second elem is {}&#34;</span>, two),
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">None</span> =&gt; println!(<span style="color:#0ff;font-weight:bold">&#34;not found&#34;</span>),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 遍历
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">for</span> i <span style="color:#fff;font-weight:bold">in</span> &amp;<span style="color:#fff;font-weight:bold">mut</span> arr2 {
</span></span><span style="display:flex;"><span>        *i *= <span style="color:#ff0;font-weight:bold">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, arr2); <span style="color:#007f7f">// [2, 4, 6, 8]
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>} <span style="color:#007f7f">// 离开作用域，销毁
</span></span></span></code></pre></div><h2 id="字符串-1">字符串</h2>
<ol>
<li>Rust中的字符串使用了UTF-8编码</li>
<li>编译器可以自动将&amp;String类型的参数强制转换为&amp;str类型</li>
<li>Rust不允许我们通过索引来获得String中的字符</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 三种创建方式
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">let</span> s1 = <span style="color:#fff;font-weight:bold">String</span>::new();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> s2 = <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> s3 = <span style="color:#0ff;font-weight:bold">&#34;hello&#34;</span>.to_string();
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}, {}, {}&#34;</span>, s1, s2, s3);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 更新: push_str() push() + fromat!
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">mut</span> h = <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>    h.push_str(<span style="color:#0ff;font-weight:bold">&#34; world&#34;</span>); <span style="color:#007f7f">// push 字符串
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, h);  <span style="color:#007f7f">// hello world
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    h.push(<span style="color:#0ff;font-weight:bold">&#39;!&#39;</span>); <span style="color:#007f7f">// push 字符
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, h);<span style="color:#007f7f">// hello world!
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> a1 = <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;hi&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> a2 = <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;world&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> a3 = a1 + &amp;a2; <span style="color:#007f7f">// a1失效，a2仍有效
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, a3);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> a1 = <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;hi&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> a2 = <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;world&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> a3 = format!(<span style="color:#0ff;font-weight:bold">&#34;{} {}&#34;</span>, a1, a2); <span style="color:#007f7f">// a1 a2仍有效
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, a3);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 索引获取,要注意正确的字节计算
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">let</span> c1 = <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;你好！&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// let c2 = &amp;c1[0..4]; // panicked at &#39;byte index 4 is not a char boundary; it is inside &#39;好&#39; (bytes 3..6) of `你好！`&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">let</span> c2 = &amp;c1[<span style="color:#ff0;font-weight:bold">0</span>..<span style="color:#ff0;font-weight:bold">3</span>]; <span style="color:#007f7f">// 你
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, c2);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 遍历
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">for</span> c <span style="color:#fff;font-weight:bold">in</span> c1.chars() { <span style="color:#007f7f">// 能正常遍历 你好！
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, c);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> c <span style="color:#fff;font-weight:bold">in</span> c1.bytes() { <span style="color:#007f7f">// 按照字节遍历，每个汉字三个字节
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, c);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="哈希表">哈希表</h2>
<ol>
<li>所有的键必须拥有相同的类型，所有的值也必须拥有相同的类型。</li>
<li>对于具有控制权的file_name和field_value，在调用insert方法后，field_name和field_value变量被移动到哈希映射中，我们再也没有办法使用这两个变量了.</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">use</span> std::collections::HashMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 初始化空哈希表——insert
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">mut</span> scores = HashMap::new() ;
</span></span><span style="display:flex;"><span>    scores.insert(<span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;Blue&#34;</span>), <span style="color:#ff0;font-weight:bold">10</span>);
</span></span><span style="display:flex;"><span>    scores.insert(<span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;Yellow&#34;</span>), <span style="color:#ff0;font-weight:bold">50</span>);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, scores);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 通过zip来构建元组的数组，通过collect来将数组转为哈希
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">let</span> team = vec![<span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;blue&#34;</span>), <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;yellow&#34;</span>)];
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> init_score = vec![<span style="color:#ff0;font-weight:bold">1</span>, <span style="color:#ff0;font-weight:bold">5</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">mut</span> score: HashMap&lt;_,_&gt; = team.iter().zip(init_score.iter()).collect();
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, score);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 读取
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">let</span> blue = score.get(&amp;<span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;blue&#34;</span>)); <span style="color:#007f7f">// 返回值为Option类型 ： Some(1)
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, blue);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 遍历
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">for</span> (k, v) <span style="color:#fff;font-weight:bold">in</span> &amp;score {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#0ff;font-weight:bold">&#34;{}, {}&#34;</span>, k, v);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 不存在时再插入
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">let</span> k_b = <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;blue&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> k_r = <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;red&#34;</span>);
</span></span><span style="display:flex;"><span>    score.entry(&amp;k_b).or_insert(&amp;<span style="color:#ff0;font-weight:bold">2</span>);
</span></span><span style="display:flex;"><span>    score.entry(&amp;k_r).or_insert(&amp;<span style="color:#ff0;font-weight:bold">3</span>);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, score);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 基于旧值更新
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">let</span> words = <span style="color:#0ff;font-weight:bold">&#34;h e l l o&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">mut</span> word_map = HashMap::new();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> word <span style="color:#fff;font-weight:bold">in</span> words.split_whitespace() {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">let</span> count = word_map.entry(word).or_insert(<span style="color:#ff0;font-weight:bold">0</span>);
</span></span><span style="display:flex;"><span>        *count+=<span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, word_map);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="泛型">泛型</h2>
<ol>
<li>Rust实现泛型的方式决定了使用泛型的代码与使用具体类型的代码相比不会有任何速度上的差异。
为了实现这一点，Rust会在编译时执行泛型代码的<strong>单态化</strong>（monomorphization）。单态化
是一个在编译期将泛型代码转换为特定代码的过程，它会将所有使用过的具体类型填入泛型参数从而得到有具体类型的代码。
在这个过程中，编译器所做的工作建泛型函数时相反：它会寻找所有泛型代码被调用过的地方，并基于该泛型代码所使用的具体类型生成代码。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> Point&lt;T, U&gt; {
</span></span><span style="display:flex;"><span>    x: T,
</span></span><span style="display:flex;"><span>    y: U,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">impl</span>&lt;T,U&gt; Point&lt;T, U&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">fn</span> mix_up&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
</span></span><span style="display:flex;"><span>        Point{
</span></span><span style="display:flex;"><span>            x: self.x,
</span></span><span style="display:flex;"><span>            y: other.y,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> p1 = Point{
</span></span><span style="display:flex;"><span>        x: <span style="color:#ff0;font-weight:bold">1</span>,
</span></span><span style="display:flex;"><span>        y: <span style="color:#ff0;font-weight:bold">2.0</span>,
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> p2 = Point{
</span></span><span style="display:flex;"><span>        x: <span style="color:#0ff;font-weight:bold">&#34;hello&#34;</span>,
</span></span><span style="display:flex;"><span>        y: <span style="color:#0ff;font-weight:bold">&#34;world&#34;</span>,
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> p3 = p1.mix_up(p2); <span style="color:#007f7f">// Point { x: 1, y: &#34;world&#34; }
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, p3);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="关联类型">关联类型</h2>
<p>关联类型是在 trait 中定义的类型占位符。一个 trait 可以定义一个或多个关联类型，这些关联类型在 trait 中使用，但没有定义具体的类型。具体类型的定义由实现 trait 的类型来提供。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">pub</span> <span style="color:#fff;font-weight:bold">trait</span> <span style="color:#fff;font-weight:bold">Iterator</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">type</span> Item;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">fn</span> next(&amp;<span style="color:#fff;font-weight:bold">mut</span> self) -&gt; <span style="color:#fff;font-weight:bold">Option</span>&lt;Self::Item&gt;;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> Counter {
</span></span><span style="display:flex;"><span>    count: <span style="color:#fff;font-weight:bold">i32</span>,
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">impl</span> <span style="color:#fff;font-weight:bold">Iterator</span> <span style="color:#fff;font-weight:bold">for</span> Counter {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">type</span> Item = <span style="color:#fff;font-weight:bold">i32</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">fn</span> next(&amp;<span style="color:#fff;font-weight:bold">mut</span> self) -&gt; <span style="color:#fff;font-weight:bold">Option</span>&lt;Self::Item&gt; {
</span></span><span style="display:flex;"><span>        self.count+=<span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">Some</span>(self.count)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">mut</span> count = Counter{count:<span style="color:#ff0;font-weight:bold">0</span>};
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, count.next());
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, count.next());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>关联类型通常用于定义某个 trait 中依赖的类型，让实现者来提供其具体类型。具体类型的定义可以根据参数或其他条件变化，从而实现更灵活、更通用的代码。</p>
<p>使用泛型实现的版本：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">pub</span> <span style="color:#fff;font-weight:bold">trait</span> <span style="color:#fff;font-weight:bold">Iterator</span>&lt;T&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">fn</span> next(&amp;<span style="color:#fff;font-weight:bold">mut</span> self) -&gt; <span style="color:#fff;font-weight:bold">Option</span>&lt;T&gt;;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> Counter {
</span></span><span style="display:flex;"><span>    count: <span style="color:#fff;font-weight:bold">i32</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">impl</span> <span style="color:#fff;font-weight:bold">Iterator</span>&lt;<span style="color:#fff;font-weight:bold">i32</span>&gt; <span style="color:#fff;font-weight:bold">for</span> Counter {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">fn</span> next(&amp;<span style="color:#fff;font-weight:bold">mut</span> self) -&gt; <span style="color:#fff;font-weight:bold">Option</span>&lt;<span style="color:#fff;font-weight:bold">i32</span>&gt; {
</span></span><span style="display:flex;"><span>        self.count += <span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">Some</span>(self.count) <span style="color:#007f7f">// 返回计数器的值
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">mut</span> counter = Counter { count: <span style="color:#ff0;font-weight:bold">0</span> };
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, counter.next()); <span style="color:#007f7f">// Some(1)
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, counter.next()); <span style="color:#007f7f">// Some(2)
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}
</span></span></code></pre></div><p>使用关联类型有何优势？</p>
<blockquote>
<p>使用关联类型可以使迭代器更加灵活和可扩展。</p>
<p>首先，关联类型允许将迭代器的项类型动态确定，也就是说，在实现 <code>Iterator</code> trait 时，可以指定 <code>Item</code> 类型是什么，不需要将其硬编码为具体的类型。这样可以使迭代器更加通用，同时也使代码更加清晰。</p>
<p>例如，如果一个实现 <code>Iterator</code> trait的类型可能返回多种类型的元素，使用关联类型可以让实现该 trait 的代码更加清晰易懂。</p>
<p>其次，使用关联类型可以允许在实现 <code>Iterator</code> trait 的类型中使用 trait bounds 进行更严格的类型检查，以避免类型错误和运行时错误。这种方法可以使代码更加可靠，并且可以让 Rust 编译器在编译期间发现潜在的错误。</p>
<p>总的来说，使用关联类型可以使迭代器更加灵活和通用，并且可以在编译期间发现类型错误，从而提高代码的可靠性。</p>
</blockquote>
<h2 id="trait">trait</h2>
<p>trait（特征）被用来向Rust编译器描述某些特定类型拥有的且能够被其他类型共享的功能，它使我们可以以一种抽象的方式来定义共享行为。我们还可以使用trait约束来将泛型参数指定为实现了某些特定行为的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">use</span> std::fmt::Debug;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 定义trait
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">pub</span> <span style="color:#fff;font-weight:bold">trait</span> User {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">fn</span> ID(self) -&gt; <span style="color:#fff;font-weight:bold">String</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 提供trait默认行为
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">pub</span> <span style="color:#fff;font-weight:bold">trait</span> User {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">fn</span> ID(self) -&gt; <span style="color:#fff;font-weight:bold">String</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;default id&#34;</span>)
</span></span><span style="display:flex;"><span>  	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 实现User
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">pub</span> <span style="color:#fff;font-weight:bold">struct</span> Emp {
</span></span><span style="display:flex;"><span>    id: <span style="color:#fff;font-weight:bold">String</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">impl</span> User <span style="color:#fff;font-weight:bold">for</span> Emp {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">fn</span> ID(self) -&gt; <span style="color:#fff;font-weight:bold">String</span> {
</span></span><span style="display:flex;"><span>        self.id
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// trait作为参数
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">fn</span> print_user(user: impl User) {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, user.ID());
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 等价于
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">fn</span> print_user2&lt;T: User&gt;(user: T) {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, user.ID());
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 通过+来指定多个trait
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">pub</span> <span style="color:#fff;font-weight:bold">trait</span> Teacher{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">fn</span> Grade(self) -&gt; <span style="color:#fff;font-weight:bold">i32</span>;    
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> print_teacher(teacher: impl User+Teacher+ Debug) {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, teacher);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 使用where语句优化trait约束
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">fn</span> print_teacher2&lt;T:User+Debug, U: User+Teacher+ Debug&gt;(teacher: T , user: U) {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, teacher);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, user);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 优化后：
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">fn</span> print_teacher3&lt;T, U&gt;(teacher:T, user:U)
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">where</span> T: User+Debug,
</span></span><span style="display:flex;"><span>          U: User+Teacher+ Debug
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, teacher);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, user);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 返回值中使用trait
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">fn</span> return_user() -&gt; impl User {
</span></span><span style="display:flex;"><span>    Emp{
</span></span><span style="display:flex;"><span>        id: <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;default_user&#34;</span>),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> bob = Emp{
</span></span><span style="display:flex;"><span>        id: <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;bob&#34;</span>),
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    print_user(bob);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="debug-trait">Debug trait</h3>
<p>DEBUG trait 定义了一种用于在调试时输出调试信息的方式。使用DEBUG trait，可以让我们以一种更加简单、可读性更高的方式打印出调试信息，从而帮助定位问题。</p>
<p>DEBUG trait 定义了一个名为 <code>fmt</code> 的方法，该方法将一个格式化器对象与当前对象进行交互，以生成用于调试输出的字符串。具体来说，DEBUG trait 适用于任何可以通过某种方式转换为字符串的类型，例如数字、字符串、集合和自定义类型。DEBUG trait 的实现需要返回一个字符串，该字符串包含该类型的当前状态和信息。</p>
<p>在 Rust 中，程序员可以使用 <code>println!</code> 宏或者 <code>format!</code> 宏来输出调试信息。这些宏本质上就是使用了 DEBUG trait 来将相关变量打印为字符串进行输出的。这些宏支持多种调试格式，例如 <code>%?</code> 表示使用 DEBUG trait 输出，<code>{:?}</code> 表示使用调试格式输出。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> Person {
</span></span><span style="display:flex;"><span>    name: <span style="color:#fff;font-weight:bold">String</span>,
</span></span><span style="display:flex;"><span>    age: <span style="color:#fff;font-weight:bold">i32</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> p = Person {
</span></span><span style="display:flex;"><span>        name: <span style="color:#0ff;font-weight:bold">&#34;Alice&#34;</span>.to_string(),
</span></span><span style="display:flex;"><span>        age: <span style="color:#ff0;font-weight:bold">30</span>,
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, p); <span style="color:#007f7f">// 使用 Debug 格式化输出
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 或者可以使用 format! 宏输出
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">let</span> s = format!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, p);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, s);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>   <span style="color:#007f7f">// 输出
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>   <span style="color:#007f7f">//Person { name: &#34;Alice&#34;, age: 30 }
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>   <span style="color:#007f7f">//Person { name: &#34;Alice&#34;, age: 30 }
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}
</span></span></code></pre></div><h3 id="copy-trait">Copy trait</h3>
<p>Copy trait定义了一种类型可以直接复制的方式。具体来说，如果一个类型实现了 Copy trait，那么它的值可以直接进行复制，而不会发生所有权转移的情况。这意味着，不需要使用 <code>clone()</code> 方法对值进行复制，而是可以使用赋值语句来进行复制操作。</p>
<p>需要注意的是，实现 Copy trait 的类型必须是满足以下条件的类型：</p>
<ul>
<li>
<p>它的大小是固定的（即在编译时已知）。</p>
</li>
<li>
<p>它的所有的成员也都满足 Copy trait。</p>
</li>
</ul>
<p>因为 Copy trait 只是进行了一次 bit-by-bit 的复制，所以只有内置类型和某些可以直接进行内存复制的自定义类型才能实现 Copy trait。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#[derive(Copy, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> Point {
</span></span><span style="display:flex;"><span>    x: <span style="color:#fff;font-weight:bold">i32</span>,
</span></span><span style="display:flex;"><span>    y: <span style="color:#fff;font-weight:bold">i32</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> p1 = Point { x: <span style="color:#ff0;font-weight:bold">0</span>, y: <span style="color:#ff0;font-weight:bold">0</span> };
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> p2 = p1; <span style="color:#007f7f">// 进行一次复制操作 不需要使用 `clone()` 方法，因为 `Point` 类型已经实现了 Copy trait
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;p1: ({}, {})&#34;</span>, p1.x, p1.y);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;p2: ({}, {})&#34;</span>, p2.x, p2.y);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>实现了copy trait的内置类型：</strong></p>
<p>• 所有的整数类型，诸如u32。
• 仅拥有两种值（true和false）的布尔类型：bool。
• 字符类型：char。
• 所有的浮点类型，诸如f64。
• 如果元组包含的所有字段的类型都是Copy的，那么这个元组也是Copy的。例如，(i32, i32)是Copy的，但(i32, String)则不是。”</p>
<h3 id="clone-trait">Clone trait</h3>
<p>Clone trait是一个标记trait，它允许程序员手动实现类型的克隆语义。任何类型都可以实现Clone trait，但是需要手动调用clone方法才能发挥作用。Clone trait没有任何前提条件，任何类型都可以实现（unsized类型除外）。</p>
<p>举个例子，假设有一个结构体Person，它有两个字段name和age，我们可以通过实现Clone trait来克隆一个Person类型的实例，如下所示</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> Person {
</span></span><span style="display:flex;"><span>    name: <span style="color:#fff;font-weight:bold">String</span>,
</span></span><span style="display:flex;"><span>    age: <span style="color:#fff;font-weight:bold">u8</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> person1 = Person {
</span></span><span style="display:flex;"><span>        name: <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;Alice&#34;</span>),
</span></span><span style="display:flex;"><span>        age: <span style="color:#ff0;font-weight:bold">20</span>,
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> person2 = person1.clone();
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;person1: {:?}, person2: {:?}&#34;</span>, person1, person2);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里我们通过实现Clone trait来克隆一个Person类型的实例，这样我们就可以得到一个新的Person类型的实例，而不是对原始实例的引用。这个新的实例和原始实例是完全独立的，它们的内存地址不同，但是它们的值是相同的。</p>
<h3 id="display-trait">Display trait</h3>
<p><code>Display trait</code> 用于将类型转换为字符串并进行打印。它通常与格式化宏 <code>println!()</code> 或者 <code>format!()</code> 一起使用，用于将自定义类型转换为可打印的字符串。</p>
<p>实现 <code>Display</code> trait 需要使用 <code>fmt::Display</code> 模块，该模块提供了 <code>fmt</code> 宏，可以将值转换为字符串并输出。</p>
<p>以下是实现 <code>Display</code> trait 的示例代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">use</span> std::fmt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> Student {
</span></span><span style="display:flex;"><span>    name: <span style="color:#fff;font-weight:bold">String</span>,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    age: <span style="color:#fff;font-weight:bold">u8</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">impl</span> fmt::Display <span style="color:#fff;font-weight:bold">for</span> Student {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">fn</span> fmt(&amp;self, f: <span style="color:#fff;font-weight:bold">&amp;</span>mut fmt::Formatter&lt;&#39;<span style="color:#fff;font-weight:bold">_</span>&gt;) -&gt; fmt::<span style="color:#fff;font-weight:bold">Result</span> {
</span></span><span style="display:flex;"><span>        write!(f, <span style="color:#0ff;font-weight:bold">&#34;Name: {}, Age: {}&#34;</span>, self.name, self.age)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> student = Student {
</span></span><span style="display:flex;"><span>        name: <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;Alice&#34;</span>),
</span></span><span style="display:flex;"><span>        age: <span style="color:#ff0;font-weight:bold">20</span>,
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, student); <span style="color:#007f7f">// Name: Alice, Age: 20
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}
</span></span></code></pre></div><p>在上面的代码中，我们定义了一个结构体 <code>Student</code>，其中包含学生的姓名和年龄。接着，我们为其实现了 <code>Display</code> trait，将学生的姓名和年龄格式化为字符串并输出。在该示例中，我们使用了 <code>write!()</code> 宏，该宏用于将数据写入缓冲区，通常与 <code>fmt::Result</code> 结合使用。最后，我们使用 <code>println!()</code> 宏输出学生信息。</p>
<h3 id="fn-trait"><strong>Fn trait</strong></h3>
<p><code>Fn</code> 是最通用的 trait，适用于不可变引用调用的函数。这意味着它只适用于不修改它们的函数或闭包，以及使用 <code>&amp;T</code> 语法或 <code>.borrow()</code> 方法在引用类型上调用它们。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> foo(x: <span style="color:#fff;font-weight:bold">i32</span>) -&gt; <span style="color:#fff;font-weight:bold">i32</span> {
</span></span><span style="display:flex;"><span>    x * <span style="color:#ff0;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> call_fn&lt;F: <span style="color:#fff;font-weight:bold">Fn</span>(<span style="color:#fff;font-weight:bold">i32</span>) -&gt; <span style="color:#fff;font-weight:bold">i32</span>&gt;(f: F) -&gt; <span style="color:#fff;font-weight:bold">i32</span> {
</span></span><span style="display:flex;"><span>    f(<span style="color:#ff0;font-weight:bold">10</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> result = call_fn(foo);
</span></span><span style="display:flex;"><span>    assert_eq!(result, <span style="color:#ff0;font-weight:bold">20</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> closure = |x| x * <span style="color:#ff0;font-weight:bold">3</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> result = call_fn(closure);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    assert_eq!(result, <span style="color:#ff0;font-weight:bold">30</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在这个例子中，<code>call_fn</code> 函数参数中的 <code>Fn</code> trait 约束限制了传递的函数参数必须实现该 trait。</p>
<h3 id="fnmut-trait"><strong>FnMut trait</strong></h3>
<p><code>FnMut</code> 与 <code>Fn</code> 类似，但是它只适用于可变引用调用的函数。这意味着它适用于通过 <code>&amp;mut T</code> 语法或 <code>.borrow_mut()</code> 方法在引用类型上调用的函数或闭包。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> bar(x: <span style="color:#fff;font-weight:bold">&amp;</span>mut <span style="color:#fff;font-weight:bold">i32</span>) {
</span></span><span style="display:flex;"><span>    *x *= <span style="color:#ff0;font-weight:bold">3</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> call_fn_mut&lt;F: <span style="color:#fff;font-weight:bold">FnMut</span>(&amp;<span style="color:#fff;font-weight:bold">mut</span> <span style="color:#fff;font-weight:bold">i32</span>)&gt;(<span style="color:#fff;font-weight:bold">mut</span> f: F) -&gt; <span style="color:#fff;font-weight:bold">i32</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">mut</span> x = <span style="color:#ff0;font-weight:bold">5</span>;
</span></span><span style="display:flex;"><span>    f(&amp;<span style="color:#fff;font-weight:bold">mut</span> x);
</span></span><span style="display:flex;"><span>    x
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> result = call_fn_mut(|x| *x *= <span style="color:#ff0;font-weight:bold">2</span>);
</span></span><span style="display:flex;"><span>    assert_eq!(result, <span style="color:#ff0;font-weight:bold">10</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> result = call_fn_mut(|z| bar(z));
</span></span><span style="display:flex;"><span>    assert_eq!(result, <span style="color:#ff0;font-weight:bold">6</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在这个例子中，<code>call_fn_mut</code> 函数参数中的 <code>FnMut</code> trait 约束限制了传递的函数参数必须实现该 trait。</p>
<h3 id="fnonce-trait"><strong>FnOnce trait</strong></h3>
<p><code>FnOnce</code> 是最具体的 trait，只适用于通过所有权调用的函数。这意味着它只适用于可移动值，即那些可以在调用过程中被移动的值，例如，在闭包中使用 <code>move</code> 关键字实现的闭包。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> call_fn_once&lt;F: <span style="color:#fff;font-weight:bold">FnOnce</span>(<span style="color:#fff;font-weight:bold">i32</span>) -&gt; R, R&gt;(f: F, x: <span style="color:#fff;font-weight:bold">i32</span>) -&gt; R {
</span></span><span style="display:flex;"><span>    f(x)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> result = call_fn_once(|x| x * <span style="color:#ff0;font-weight:bold">4</span>, <span style="color:#ff0;font-weight:bold">3</span>);
</span></span><span style="display:flex;"><span>    assert_eq!(result, <span style="color:#ff0;font-weight:bold">12</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> closure = |_: <span style="color:#fff;font-weight:bold">i32</span>| <span style="color:#0ff;font-weight:bold">&#34;hello&#34;</span>.to_string();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> result = call_fn_once(closure, <span style="color:#ff0;font-weight:bold">0</span>);
</span></span><span style="display:flex;"><span>    assert_eq!(result, <span style="color:#0ff;font-weight:bold">&#34;hello&#34;</span>.to_string());
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// example2:
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> s = <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> closure = |_: <span style="color:#fff;font-weight:bold">i32</span>| {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">let</span> s = s; <span style="color:#007f7f">// 函数体内移动s
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, s);
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    closure(<span style="color:#ff0;font-weight:bold">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// println!(&#34;{}&#34;, s); // 会报错，因为s的所有权已经被转移
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  	<span style="color:#007f7f">// closure(1); // 会报错，因为s的所有权已经被转移
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// example3:
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> s = <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> closure = <span style="color:#fff;font-weight:bold">move</span> |_: <span style="color:#fff;font-weight:bold">i32</span>| { <span style="color:#007f7f">// 使用move声明s被move
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, s);
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    closure(<span style="color:#ff0;font-weight:bold">0</span>);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, s); <span style="color:#007f7f">//会报错，因为s被移动了
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}
</span></span></code></pre></div><ul>
<li>
<p><code>Fn</code> trait 适用于不可变引用调用的函数。</p>
</li>
<li>
<p><code>FnMut</code> trait 适用于可变引用调用的函数。</p>
</li>
<li>
<p><code>FnOnce</code> trait 适用于通过所有权调用的函数。</p>
</li>
</ul>
<h2 id="引用中的生命周期">引用中的生命周期</h2>
<p>当引用的生命周期可能以不同的方式相互关联时，我们就必须手动标注生命周期。Rust需要我们注明泛型生命周期参数之间的关系，来确保运行时实际使用的引用一定是有效的。</p>
<p>生命周期的标注使用了一种明显不同的语法：<strong>它们的参数名称必须以撇号（&rsquo;）开头，且通常使用全小写字符</strong>。与泛型一样，它们的名称通常也会非常简短。&lsquo;a被大部分开发者选择作为默认使用的名称。我们会将生命周期参数的标注填写在&amp;引用运算符之后，并通过一个空格符来将标注与引用类型区分开来。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> s = longest(<span style="color:#0ff;font-weight:bold">&#34;hi&#34;</span>, <span style="color:#0ff;font-weight:bold">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, s);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> longest&lt;&#39;<span style="color:#007f7f">a</span>&gt; (x: <span style="color:#fff;font-weight:bold">&amp;</span>&#39;<span style="color:#007f7f">a</span> <span style="color:#fff;font-weight:bold">str</span>, y: <span style="color:#fff;font-weight:bold">&amp;</span>&#39;<span style="color:#007f7f">a</span> <span style="color:#fff;font-weight:bold">str</span>) -&gt; <span style="color:#fff;font-weight:bold">&amp;</span>&#39;<span style="color:#007f7f">a</span> <span style="color:#fff;font-weight:bold">str</span> { <span style="color:#007f7f">// 泛型生命周期&#39;a会被具体化为x与y两者中生命周期较短的那一个
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> x.len() &gt; y.len() {
</span></span><span style="display:flex;"><span>        x
</span></span><span style="display:flex;"><span>    }<span style="color:#fff;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>        y
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>当我们在函数签名中指定生命周期参数时，我们并没有改变任何传入值或返回值的生命周期。我们只是向借用检查器指出了一些可以用于检查非法调用的约束。</p>
</blockquote>
<h3 id="计算生命周期的三个原则">计算生命周期的三个原则</h3>
<blockquote>
<p>函数参数或方法参数中的生命周期被称为输入生命周期（input lifetime），而返回值的生命周期则被称为输出生命周期（output lifetime）。</p>
</blockquote>
<p>在没有显式标注的情况下，编译器目前使用了3种规则来计算引用的生命周期:</p>
<ol>
<li>每一个引用参数都会拥有自己的生命周期参数。换句话说，单参数函数拥有一个生命周期参数：fn foo&lt;&lsquo;a&gt;(x: &amp;&lsquo;a i32)；双参数函数拥有两个不同的生命周期参数：fn foo&lt;&lsquo;a, &lsquo;b&gt;(x: &amp;&lsquo;a i32, y: &amp;&lsquo;b i32)；以此类推。</li>
<li>当只存在一个输入生命周期参数时，这个生命周期会被赋予给所有输出生命周期参数，例如fn foo&lt;&lsquo;a&gt;(x: &amp;&lsquo;a i32) -&gt; &amp;&lsquo;a i32。</li>
<li>当拥有多个输入生命周期参数，而其中一个是&amp;self或&amp;mut self时，self的生命周期会被赋予给所有的输出生命周期参数。这条规则使方法更加易于阅读和编写，因为它省略了一些不必要的符号。</li>
</ol>
<p>当不满足以上三个原则时，编译器无法确认生命周期，于是会报错。</p>
<h3 id="静态生命周期">静态生命周期</h3>
<p>Rust中还存在一种特殊的生命周期&rsquo;static，它表示整个程序的执行期。所有的字符串字面量都拥有&rsquo;static生命周期。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> s: <span style="color:#fff;font-weight:bold">&amp;</span>&#39;<span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">str</span> = <span style="color:#0ff;font-weight:bold">&#34;I have a static lifetime.&#34;</span>;
</span></span></code></pre></div><h2 id="迭代器">迭代器</h2>
<ol>
<li>
<p>所有的迭代器都实现了定义于标准库中的<code>Iterator trait</code></p>
</li>
<li>
<p>Iterator trait只要求实现者手动定义一个方法：<code>next</code>方法，它会在每次被调用时返回一个包裹在<code>Some</code>中的迭代器元素，并在迭代结束时返回<code>None</code>。</p>
</li>
<li>
<p>iter方法生成的是一个不可变引用的迭代器，我们通过<code>next</code>取得的值实际上是指向动态数组中各个元素的<strong>不可变引用</strong>。如果你需要创建一个<strong>取得v1所有权并返回元素本身的迭代器</strong>，那么你可以使用<code>into_iter</code>方法。类似地，如果你需要<strong>可变引用的迭代器</strong>，那么你可以使用<code>iter_mut</code>方法。</p>
</li>
<li>
<p>迭代器适配器是<strong>惰性</strong>的，除非我们消耗迭代器，否则什么事情都不会发生。</p>
</li>
<li>
<p>尽管迭代器是一种高层次的抽象，但它在编译后生成了与手写底层代码几乎一样的产物。迭代器是Rust语言中的一种<strong>零开销抽象</strong>（zero-cost abstraction），这个词意味着我们在使用这些抽象时不会引入额外的运行时开销</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> v1 = vec![<span style="color:#ff0;font-weight:bold">1</span>,<span style="color:#ff0;font-weight:bold">2</span>,<span style="color:#ff0;font-weight:bold">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">mut</span> v1_iter = v1.iter();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> n1 = v1_iter.next();
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:#?}&#34;</span>, n1);
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span><span style="color:#007f7f">//Some(
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">//    1,
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">//)
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> v1: <span style="color:#fff;font-weight:bold">Vec</span>&lt;<span style="color:#fff;font-weight:bold">i32</span>&gt; = vec![<span style="color:#ff0;font-weight:bold">1</span>,<span style="color:#ff0;font-weight:bold">2</span>,<span style="color:#ff0;font-weight:bold">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> v2: <span style="color:#fff;font-weight:bold">Vec</span>&lt;_&gt; = v1.iter().map(|x| x+<span style="color:#ff0;font-weight:bold">1</span>).collect();
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:#?}&#34;</span>, v2);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> shoes: <span style="color:#fff;font-weight:bold">Vec</span>&lt;_&gt; = shoes_in_my_size(vec![Shoe{size: <span style="color:#ff0;font-weight:bold">10</span>},Shoe{size: <span style="color:#ff0;font-weight:bold">30</span>}], <span style="color:#ff0;font-weight:bold">10</span>);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{:#?}&#34;</span>, shoes);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#[derive (PartialEq, Debug) ]</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> Shoe {
</span></span><span style="display:flex;"><span>    size: <span style="color:#fff;font-weight:bold">u32</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> shoes_in_my_size (shoes: <span style="color:#fff;font-weight:bold">Vec</span>&lt;Shoe&gt;, shoe_size: <span style="color:#fff;font-weight:bold">u32</span>) -&gt;<span style="color:#fff;font-weight:bold">Vec</span>&lt;Shoe&gt; {
</span></span><span style="display:flex;"><span>    shoes.into_iter().filter(|s| s.size==shoe_size).collect ()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// [
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">//     2,
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">//     3,
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">//     4,
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// ]
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// [
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">//     Shoe {
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">//         size: 10,
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">//     },
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// ]
</span></span></span></code></pre></div><h2 id="错误处理">错误处理</h2>
<ol>
<li>
<p>失败时触发panic的快捷方式：</p>
<ol>
<li>unwrap：<code>let f = File::open(&quot;a.txt&quot;).unwrap();</code>，当open()出错时，直接panic，当没有错误时，将open()返回的Result&lt;T,E&gt;中的正常返回值解析出来赋值给f。</li>
<li>expect：区别于unwrap，expect能够指定报错信息。<code>let f = File::open(&quot;a.txt&quot;).expect(&quot;open Failed&quot;);</code></li>
</ol>
</li>
<li>
<p>错误传播：使用<code>?</code>运算符来将错误返回给调用者(<code>?</code>运算符只能被用于返回Result的函数)</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">use</span> std::io;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">use</span> std::io::Read;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">use</span> std::fs::File;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> read_username_from_file() -&gt; <span style="color:#fff;font-weight:bold">Result</span>&lt;<span style="color:#fff;font-weight:bold">String</span>, io::Error&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> f = File::open(<span style="color:#0ff;font-weight:bold">&#34;hello. txt&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">mut</span> f = <span style="color:#fff;font-weight:bold">match</span> f {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">Ok</span>(file) =&gt; file,
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">Err</span>(e) =&gt; <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">Err</span>(e),
</span></span><span style="display:flex;"><span>    }; 
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">mut</span> s = <span style="color:#fff;font-weight:bold">String</span>::new(); 
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">match</span> f.read_to_string(&amp;<span style="color:#fff;font-weight:bold">mut</span> s) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">Ok</span>(_) =&gt; <span style="color:#fff;font-weight:bold">Ok</span>(s),
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">Err</span>(e) =&gt; <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">Err</span>(e),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用<code>?</code>运算符。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">use</span> std::io;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">use</span> std::io::Read;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">use</span> std::fs::File;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> read_username_from_file() -&gt; <span style="color:#fff;font-weight:bold">Result</span>&lt;<span style="color:#fff;font-weight:bold">String</span>, io::Error&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">mut</span> f = File::open(<span style="color:#0ff;font-weight:bold">&#34;hello. txt&#34;</span>)?; 
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">mut</span> s = <span style="color:#fff;font-weight:bold">String</span>::new(); 
</span></span><span style="display:flex;"><span>    f.read_to_string(&amp;<span style="color:#fff;font-weight:bold">mut</span> s)?;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">Ok</span> (s)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用<strong>链式调用</strong>进一步优化</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">use</span> std::io;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">use</span> std::io::Read;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">use</span> std::fs::File;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> read_username_from_file() -&gt; <span style="color:#fff;font-weight:bold">Result</span>&lt;<span style="color:#fff;font-weight:bold">String</span>, io::Error&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">mut</span> s = <span style="color:#fff;font-weight:bold">String</span>::new(); 
</span></span><span style="display:flex;"><span>    File::open(<span style="color:#0ff;font-weight:bold">&#34;hello. txt&#34;</span>)?.read_to_string(&amp;<span style="color:#fff;font-weight:bold">mut</span> s)?;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">Ok</span>(s)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ol>
<h2 id="模块">模块</h2>
<p>rust 使用 <code>mod</code> 关键词用来定义模块和引入模块。</p>
<p><code>mod</code> 和 <code>use</code> 进行区分：<strong><code>use</code> 仅仅是在存在模块的前提下，调整调用路径，而没有引入模块的功能，引入模块使用 <code>mod</code></strong>。</p>
<p>mod调用”本地“函数，需要使用<code>super</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> hi() {
</span></span><span style="display:flex;"><span>    print!(<span style="color:#0ff;font-weight:bold">&#34;hi&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">mod</span> world {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">pub</span> <span style="color:#fff;font-weight:bold">fn</span> en() {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">super</span>::hi();
</span></span><span style="display:flex;"><span>        print!(<span style="color:#0ff;font-weight:bold">&#34;world&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>mod之间的调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">mod</span> world {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">pub</span> <span style="color:#fff;font-weight:bold">fn</span> en() {
</span></span><span style="display:flex;"><span>        print!(<span style="color:#0ff;font-weight:bold">&#34;world&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">mod</span> hi {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">pub</span> <span style="color:#fff;font-weight:bold">fn</span> en() {
</span></span><span style="display:flex;"><span>        print!(<span style="color:#0ff;font-weight:bold">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">crate</span>::world::en(); <span style="color:#007f7f">// 绝对路径
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">super</span>::world::en(); <span style="color:#007f7f">// 相对路径
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 或者使用use导入
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">mod</span> hi {
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">use</span> <span style="color:#fff;font-weight:bold">crate</span>::world <span style="color:#fff;font-weight:bold">as</span> world2;
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">pub</span> <span style="color:#fff;font-weight:bold">fn</span> en() {
</span></span><span style="display:flex;"><span>    print!(<span style="color:#0ff;font-weight:bold">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>    world2::en();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="重新导入-pub-use">重新导入-pub use</h3>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">mod</span> hello {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">pub</span> <span style="color:#fff;font-weight:bold">mod</span> hello_mod {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">pub</span> <span style="color:#fff;font-weight:bold">fn</span> hi() {
</span></span><span style="display:flex;"><span>            println!(<span style="color:#0ff;font-weight:bold">&#34;Hello from hello_mod!&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">mod</span> say {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">pub</span> <span style="color:#fff;font-weight:bold">use</span> <span style="color:#fff;font-weight:bold">super</span>::hello::hello_mod;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    say::hello_mod::hi();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>通过 pub use 能够将被use的模块hello_mod重新导入到say，此时hello_mod就是say的一个子模块。</p>
<p>如果不使用pub，那么只能在say中使用hello_mod，使用pub后，可以在导入了say模块的地方使用hello_mod.</p>
<h3 id="文件模块"><strong>文件模块</strong></h3>
<p>以下代码可以用文件隔离：</p>
<p>原代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#007f7f">// main.rs
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">mod</span> hello {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">pub</span> <span style="color:#fff;font-weight:bold">mod</span> hello_mod {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">pub</span> <span style="color:#fff;font-weight:bold">fn</span> hi() {
</span></span><span style="display:flex;"><span>            println!(<span style="color:#0ff;font-weight:bold">&#34;Hello from hello_mod!&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>隔离后的代码</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#007f7f">// main.rs
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">mod</span> hello;
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// hello.rs
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">pub</span> <span style="color:#fff;font-weight:bold">mod</span> hello_mod {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">pub</span> <span style="color:#fff;font-weight:bold">fn</span> hi() {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#0ff;font-weight:bold">&#34;Hello from hello_mod!&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>即文件就是模块。</p>
<h3 id="目录模块"><strong>目录模块</strong></h3>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>├── ho
</span></span><span style="display:flex;"><span>│   ├── hello.rs
</span></span><span style="display:flex;"><span>│   └── mod.rs
</span></span><span style="display:flex;"><span>└── main.rs
</span></span></code></pre></div><p>将hello_mod移动到ho目录下：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#007f7f">// hello.rs
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">pub</span> <span style="color:#fff;font-weight:bold">mod</span> hello_mod {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">pub</span> <span style="color:#fff;font-weight:bold">fn</span> hi() {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#0ff;font-weight:bold">&#34;Hello from hello_mod!&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>对于目录来说，如果要作为模块，需要创建<code>mod.rs</code>，并标记要导出的模块（也就是文件）：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">pub</span> <span style="color:#fff;font-weight:bold">mod</span> hello;
</span></span></code></pre></div><p>此时可以引入该模块需要：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">mod</span> ho; <span style="color:#007f7f">// 引入目录模块
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    ho::hello::hello_mod::hi(); <span style="color:#007f7f">// 分别是目录模块::文件模块::文件内第一层模块::函数
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}
</span></span></code></pre></div><h2 id="闭包">闭包</h2>
<p>闭包vs函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#007f7f">// 闭包实现
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">let</span> say_hi = |lan| {
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">match</span> lan {
</span></span><span style="display:flex;"><span>    <span style="color:#0ff;font-weight:bold">&#34;en&#34;</span> =&gt; <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;hi&#34;</span>),
</span></span><span style="display:flex;"><span>    _ =&gt; <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;你好&#34;</span>),
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 函数实现
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">fn</span> say_hi(lan: <span style="color:#fff;font-weight:bold">&amp;</span><span style="color:#fff;font-weight:bold">str</span>) -&gt; <span style="color:#fff;font-weight:bold">String</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">match</span> lan {
</span></span><span style="display:flex;"><span>        <span style="color:#0ff;font-weight:bold">&#34;en&#34;</span> =&gt; <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;hi&#34;</span>),
</span></span><span style="display:flex;"><span>        _ =&gt; <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;你好&#34;</span>),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 闭包实现
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">let</span> x = <span style="color:#ff0;font-weight:bold">4</span>;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> equal = |z| z==x;
</span></span><span style="display:flex;"><span>equal(<span style="color:#ff0;font-weight:bold">5</span>);
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 函数实现
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">fn</span> equal(x: <span style="color:#fff;font-weight:bold">i32</span>, z: <span style="color:#fff;font-weight:bold">i32</span>) -&gt; <span style="color:#fff;font-weight:bold">bool</span>{
</span></span><span style="display:flex;"><span>  x == z
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>主要的区别在于</p>
<ol>
<li><strong>闭包中的参数和返回值不需要声明类型</strong>，这是因为使用闭包的场景通常比较简单，编译器很容易推断出参数和返回值的类型。</li>
<li><strong>闭包可以引用当前环境上下文中的变量</strong>，而函数只能通过参数引入。</li>
</ol>
<p>标准库中提供了一系列Fn trait，而<strong>所有的闭包都至少实现了Fn、FnMut及FnOnce中的一个trait</strong>。这些 trait 作为约束来确保我们的函数接收一个符合要求的函数类型。</p>
<p><strong>返回闭包</strong></p>
<p>rust中需要确定类型大小，因此需要用Box来包裹函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> returns_closure() -&gt; <span style="color:#fff;font-weight:bold">Box</span>&lt;<span style="color:#fff;font-weight:bold">dyn</span> <span style="color:#fff;font-weight:bold">Fn</span>(<span style="color:#fff;font-weight:bold">i32</span>) -&gt; <span style="color:#fff;font-weight:bold">i32</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">Box</span>::new(|x| x + <span style="color:#ff0;font-weight:bold">1</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="智能指针">智能指针</h2>
<p>智能指针是一些数据结构，其行为类似于指针但拥有额外的元数据和附加功能。</p>
<p>这些用来实现智能指针的结构体会实现Deref和Drop这两个trait.“Deref trait使得智能指针结构体的实例拥有与引用一致的行为，它使你可以编写出能够同时用于引用和智能指针的代码。Drop trait则使你可以自定义智能指针离开作用域时运行的代码。”</p>
<h3 id="boxt"><code>Box&lt;T&gt;</code></h3>
<p>box可以让我们将数据存储在堆上，并在栈上保留指向堆数据的指针。</p>
<p>常用场景：</p>
<ol>
<li>
<p>当你拥有一个无法在编译时确定大小的类型，但又想要在一个要求固定尺寸的上下文环境中使用这个类型的值时。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#007f7f">// 这段代码编译报错：`recursive type List has infinite size`。通过box可以设置List的大小。
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">enum</span> List {
</span></span><span style="display:flex;"><span>    Cons(<span style="color:#fff;font-weight:bold">i32</span>, List),
</span></span><span style="display:flex;"><span>    Nil,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 正常编译的代码
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">enum</span> List {
</span></span><span style="display:flex;"><span>    Cons(<span style="color:#fff;font-weight:bold">i32</span>, <span style="color:#fff;font-weight:bold">Box</span>&lt;List&gt;),
</span></span><span style="display:flex;"><span>    Nil,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p>当你需要传递大量数据的所有权，但又不希望产生大量数据的复制行为时。</p>
<p>转移大量数据的所有权可能会花费较多的时间，因为这些数据需要在栈上进行逐一复制。为了提高性能，你可以借助装箱将这些数据存储到堆上。通过这种方式，我们只需要在转移所有权时复制指针本身即可，而不必复制它指向的全部堆数据</p>
</li>
<li>
<p>当你希望拥有一个实现了指定trait的类型值，但又不关心具体的类型时。</p>
</li>
</ol>
<h3 id="rct"><code>Rc&lt;T&gt;</code></h3>
<p>基于引用计数（reference counting）的智能指针类型会通过记录所有者的数量来使<strong>一份数据被多个所有者同时持有，并在没有任何所有者时自动清理数据</strong>。</p>
<p>只能用于单线程。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> Person {
</span></span><span style="display:flex;"><span>    name: <span style="color:#fff;font-weight:bold">String</span>,
</span></span><span style="display:flex;"><span>    age: <span style="color:#fff;font-weight:bold">u8</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> person = Person {
</span></span><span style="display:flex;"><span>        name: <span style="color:#0ff;font-weight:bold">&#34;Alice&#34;</span>.to_string(),
</span></span><span style="display:flex;"><span>        age: <span style="color:#ff0;font-weight:bold">25</span>,
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> shared_person = Rc::new(person); <span style="color:#007f7f">// 创建一个 Rc 智能指针，共享 Person
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> alice = shared_person.clone(); <span style="color:#007f7f">// 增加引用计数, 执行深度拷贝
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    println!(<span style="color:#0ff;font-weight:bold">&#34;Alice reference count: {:?}&#34;</span>, Rc::strong_count(&amp;alice)); <span style="color:#007f7f">// 输出 2
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">let</span> bob = Rc::clone(&amp;shared_person); <span style="color:#007f7f">// 增加引用计数, 执行浅度拷贝
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    println!(<span style="color:#0ff;font-weight:bold">&#34;Bob reference count: {:?}&#34;</span>, Rc::strong_count(&amp;bob)); <span style="color:#007f7f">// 输出 3
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 读取共享的 Person
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    println!(<span style="color:#0ff;font-weight:bold">&#34;Alice: {} is {} years old&#34;</span>, alice.name, alice.age);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;Bob: {} is {} years old&#34;</span>, bob.name, bob.age);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">drop</span>(bob); <span style="color:#007f7f">// 减少 Bob 的引用计数，释放智能指针
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;Alice reference count: {:?}&#34;</span>, Rc::strong_count(&amp;alice)); <span style="color:#007f7f">// 输出 2
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}
</span></span></code></pre></div><h3 id="refcellt"><code>RefCell&lt;T&gt;</code></h3>
<p>对于使用一般引用和Box<T>的代码，Rust会在编译阶段强制代码遵守这些借用规则。而对于使用RefCell<T>的代码，Rust则只会在运行时检查这些规则，并在出现违反借用规则的情况下触发panic来提前中止程序。</p>
<p>RefCell<T>会记录当前存在多少个活跃的Ref<T>和RefMut<T>智能指针。每次调用borrow方法时，RefCell<T>会将活跃的不可变借用计数加1，并且在任何一个Ref<T>的值离开作用域被释放时，不可变借用计数将减1。RefCell<T>会基于这一技术来维护和编译器同样的借用检查规则：在任何一个给定的时间里，它只允许你拥有多个不可变借用或一个可变借用。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> Person {
</span></span><span style="display:flex;"><span>    name: <span style="color:#fff;font-weight:bold">String</span>,
</span></span><span style="display:flex;"><span>    age: RefCell&lt;<span style="color:#fff;font-weight:bold">u8</span>&gt;,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> person = Person {
</span></span><span style="display:flex;"><span>        name: <span style="color:#0ff;font-weight:bold">&#34;Alice&#34;</span>.to_string(),
</span></span><span style="display:flex;"><span>        age: RefCell::new(<span style="color:#ff0;font-weight:bold">25</span>),
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">mut</span> age = person.age.borrow_mut(); <span style="color:#007f7f">// 获取可变引用，并在代码块结束时自动释放
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        *age += <span style="color:#ff0;font-weight:bold">1</span>; <span style="color:#007f7f">// 修改年龄
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> age = person.age.borrow(); <span style="color:#007f7f">// 获取不可变引用
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{} is now {} years old&#34;</span>, person.name, *age);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="weakt"><code>Weak&lt;T&gt;</code></h3>
<p>通过<code>Weak&lt;T&gt;</code>来避免Rc中互相引用而导致的内存泄漏。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">use</span> std::rc::{Rc, Weak};
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">use</span> std::cell::RefCell;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> Person {
</span></span><span style="display:flex;"><span>    name: <span style="color:#fff;font-weight:bold">String</span>,
</span></span><span style="display:flex;"><span>    partner: RefCell&lt;<span style="color:#fff;font-weight:bold">Option</span>&lt;Weak&lt;Person&gt;&gt;&gt;,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">impl</span> Person {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">fn</span> new(name: <span style="color:#fff;font-weight:bold">&amp;</span><span style="color:#fff;font-weight:bold">str</span>) -&gt; Rc&lt;Self&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">let</span> person = Rc::new(Self {
</span></span><span style="display:flex;"><span>            name: name.to_string(),
</span></span><span style="display:flex;"><span>            partner: RefCell::new(<span style="color:#fff;font-weight:bold">None</span>),
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 将自己存储到伴侣的引用中
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">let</span> weak_person = Rc::downgrade(&amp;person); <span style="color:#007f7f">// 将person降级为Weak&lt;Person&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        *person.partner.borrow_mut() = <span style="color:#fff;font-weight:bold">Some</span>(weak_person);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        person
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">fn</span> get_partner(&amp;self) -&gt; <span style="color:#fff;font-weight:bold">Option</span>&lt;Rc&lt;Self&gt;&gt; {
</span></span><span style="display:flex;"><span>        self.partner.borrow().as_ref().and_then(|weak| weak.upgrade()) <span style="color:#007f7f">// 将partner升级为Rc&lt;Person&gt;并返回
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> alice = Person::new(<span style="color:#0ff;font-weight:bold">&#34;Alice&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> bob = Person::new(<span style="color:#0ff;font-weight:bold">&#34;Bob&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 设置伴侣
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    alice.get_partner().unwrap().partner.borrow_mut().replace(Rc::downgrade(&amp;bob));
</span></span><span style="display:flex;"><span>    bob.get_partner().unwrap().partner.borrow_mut().replace(Rc::downgrade(&amp;alice));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 输出伴侣名字
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#39;s partner is {}&#34;</span>, alice.name, alice.get_partner().unwrap().name);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#39;s partner is {}&#34;</span>, bob.name, bob.get_partner().unwrap().name);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// Alice 被回收
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">drop</span>(alice);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// Bob 的伴侣为空
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    assert!(bob.get_partner().is_none());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="结合rc和refcell实现可变链表">结合Rc和RefCell实现可变链表</h3>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">enum</span> List {
</span></span><span style="display:flex;"><span>    Cons(Rc&lt;RefCell&lt;<span style="color:#fff;font-weight:bold">i32</span>&gt;&gt;, Rc&lt;List&gt;),
</span></span><span style="display:flex;"><span>    Nil,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">use</span> <span style="color:#fff;font-weight:bold">crate</span>::List::{Cons, Nil};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> value = Rc::new(RefCell::new(<span style="color:#ff0;font-weight:bold">5</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> b = Cons(Rc::new(RefCell::new(<span style="color:#ff0;font-weight:bold">6</span>)), Rc::clone(&amp;a));
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> c = Cons(Rc::new(RefCell::new(<span style="color:#ff0;font-weight:bold">10</span>)), Rc::clone(&amp;a));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    *value.borrow_mut() += <span style="color:#ff0;font-weight:bold">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;a after = {:?}&#34;</span>, a); <span style="color:#007f7f">// a after = Cons(RefCell { value: 15 }, Nil)
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    println!(<span style="color:#0ff;font-weight:bold">&#34;b after = {:?}&#34;</span>, b); <span style="color:#007f7f">// b after = Cons(RefCell { value: 6 }, Cons(RefCell { value: 15 }, Nil))
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    println!(<span style="color:#0ff;font-weight:bold">&#34;c after = {:?}&#34;</span>, c); <span style="color:#007f7f">// c after = Cons(RefCell { value: 10 }, Cons(RefCell { value: 15 }, Nil))
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}
</span></span></code></pre></div><p>通过使用RefCell<T>，我们拥有的List保持了表面上的不可变状态，并能够在必要时借由RefCell<T>提供的方法来修改其内部存储的数据。</p>
<h2 id="并发">并发</h2>
<h3 id="线程">线程</h3>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">use</span> std::{sync::mpsc, thread, time::Duration};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> example() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> (tx, rx) = mpsc::channel();
</span></span><span style="display:flex;"><span>    thread::spawn(<span style="color:#fff;font-weight:bold">move</span> || { <span style="color:#007f7f">// 通过thread::spawn创建线程 通过move实现所有权转移
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">let</span> vals = vec![
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;hi&#34;</span>),
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;你好&#34;</span>),
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">String</span>::from(<span style="color:#0ff;font-weight:bold">&#34;hello&#34;</span>),
</span></span><span style="display:flex;"><span>        ];
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">for</span> val <span style="color:#fff;font-weight:bold">in</span> vals {
</span></span><span style="display:flex;"><span>            tx.send(val).unwrap();
</span></span><span style="display:flex;"><span>            thread::sleep(Duration::from_secs(<span style="color:#ff0;font-weight:bold">1</span>));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> received <span style="color:#fff;font-weight:bold">in</span> rx { <span style="color:#007f7f">// 接收数据
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        println!(<span style="color:#0ff;font-weight:bold">&#34;Got： {}&#34;</span>, received);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="锁原子">锁+原子</h3>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">use</span> std::sync::{Mutex, Arc};
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">use</span> std::thread;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> counter = Arc::new(Mutex::new(<span style="color:#ff0;font-weight:bold">0</span>)); <span style="color:#007f7f">// 原子数据
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">mut</span> handles = vec![];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> _ <span style="color:#fff;font-weight:bold">in</span> <span style="color:#ff0;font-weight:bold">0</span>..<span style="color:#ff0;font-weight:bold">10</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">let</span> counter = Arc::clone(&amp;counter);
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">let</span> handle = thread::spawn(<span style="color:#fff;font-weight:bold">move</span> || {
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">mut</span> num = counter.lock().unwrap();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            *num += <span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>        handles.push(handle);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> handle <span style="color:#fff;font-weight:bold">in</span> handles {
</span></span><span style="display:flex;"><span>        handle.join().unwrap();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;Result: {}&#34;</span>, *counter.lock().unwrap());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="模式">模式</h2>
<h3 id="范围模式">范围模式</h3>
<p>左闭右开：<code>..</code></p>
<p>左闭右闭：<code>..=</code></p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> arr: <span style="color:#fff;font-weight:bold">Vec</span>&lt;<span style="color:#fff;font-weight:bold">i32</span>&gt; = vec![<span style="color:#ff0;font-weight:bold">1</span>,<span style="color:#ff0;font-weight:bold">2</span>,<span style="color:#ff0;font-weight:bold">3</span>,<span style="color:#ff0;font-weight:bold">4</span>,<span style="color:#ff0;font-weight:bold">5</span>];
</span></span><span style="display:flex;"><span>println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, &amp;arr[<span style="color:#ff0;font-weight:bold">1</span>..<span style="color:#ff0;font-weight:bold">2</span>]); <span style="color:#007f7f">// [2]
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>println!(<span style="color:#0ff;font-weight:bold">&#34;{:?}&#34;</span>, &amp;arr[<span style="color:#ff0;font-weight:bold">1</span>..=<span style="color:#ff0;font-weight:bold">2</span>]); <span style="color:#007f7f">// [2, 3]
</span></span></span></code></pre></div><p>对于<code>@绑定</code>只能使用<code>..=</code>?</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> msg = Message::Hello { id: <span style="color:#ff0;font-weight:bold">5</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">match</span> msg {
</span></span><span style="display:flex;"><span>        Message::Hello {
</span></span><span style="display:flex;"><span>            id: id_variable @ <span style="color:#ff0;font-weight:bold">3</span>..=<span style="color:#ff0;font-weight:bold">7</span>,
</span></span><span style="display:flex;"><span>        } =&gt; {
</span></span><span style="display:flex;"><span>            println!(<span style="color:#0ff;font-weight:bold">&#34;Found an id in range: {}&#34;</span>, id_variable)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        Message::Hello { id: <span style="color:#ff0;font-weight:bold">10</span>..=<span style="color:#ff0;font-weight:bold">12</span> } =&gt; {
</span></span><span style="display:flex;"><span>            println!(<span style="color:#0ff;font-weight:bold">&#34;Found an id in another range&#34;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        Message::Hello { id } =&gt; {
</span></span><span style="display:flex;"><span>            println!(<span style="color:#0ff;font-weight:bold">&#34;Found some other id: {}&#34;</span>, id)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">enum</span> Message {
</span></span><span style="display:flex;"><span>    Hello { id: <span style="color:#fff;font-weight:bold">i32</span> },
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="match中的模式">match中的模式</h3>
<p>多重模式——使用|来表示or：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> x = <span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">match</span> x {
</span></span><span style="display:flex;"><span>    <span style="color:#ff0;font-weight:bold">1</span> | <span style="color:#ff0;font-weight:bold">2</span> =&gt; println!(<span style="color:#0ff;font-weight:bold">&#34;one or two&#34;</span>),
</span></span><span style="display:flex;"><span>    <span style="color:#ff0;font-weight:bold">3</span> =&gt; println!(<span style="color:#0ff;font-weight:bold">&#34;three&#34;</span>),
</span></span><span style="display:flex;"><span>    _ =&gt; println!(<span style="color:#0ff;font-weight:bold">&#34;anything&#34;</span>),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>解构赋值：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> Point {
</span></span><span style="display:flex;"><span>    x: <span style="color:#fff;font-weight:bold">i32</span>,
</span></span><span style="display:flex;"><span>    y: <span style="color:#fff;font-weight:bold">i32</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> p = Point{x:<span style="color:#ff0;font-weight:bold">1</span>, y:<span style="color:#ff0;font-weight:bold">2</span>};
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>  	<span style="color:#fff;font-weight:bold">match</span> p {
</span></span><span style="display:flex;"><span>        Point { x, y: <span style="color:#ff0;font-weight:bold">0</span> } =&gt; println!(<span style="color:#0ff;font-weight:bold">&#34;on the x axis at {}&#34;</span>, x),
</span></span><span style="display:flex;"><span>        Point { x: <span style="color:#ff0;font-weight:bold">0</span>, y } =&gt; println!(<span style="color:#0ff;font-weight:bold">&#34;on the y axis at {}&#34;</span>, y),
</span></span><span style="display:flex;"><span>        Point { x, y } =&gt; print!(<span style="color:#0ff;font-weight:bold">&#34;other at ({}, {})&#34;</span>, x, y),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>匹配守卫：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> num = <span style="color:#fff;font-weight:bold">Some</span>(<span style="color:#ff0;font-weight:bold">4</span>);
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">match</span> num {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">Some</span>(x) <span style="color:#fff;font-weight:bold">if</span> x &lt; <span style="color:#ff0;font-weight:bold">5</span> =&gt; println!(<span style="color:#0ff;font-weight:bold">&#34;less than five: {}&#34;</span>, x), <span style="color:#007f7f">// 增强意图
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">Some</span>(x) =&gt; println!(<span style="color:#0ff;font-weight:bold">&#34;{}&#34;</span>, x),
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">None</span>() =&gt; println!(<span style="color:#0ff;font-weight:bold">&#34;none&#34;</span>),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>@绑定：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">enum</span> Message {
</span></span><span style="display:flex;"><span>    Hello { id: <span style="color:#fff;font-weight:bold">i32</span> },
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> msg = Message::Hello { id: <span style="color:#ff0;font-weight:bold">5</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">match</span> msg {
</span></span><span style="display:flex;"><span>    Message::Hello { id: id_variable @ <span style="color:#ff0;font-weight:bold">3</span>..=<span style="color:#ff0;font-weight:bold">7</span> } =&gt; {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#0ff;font-weight:bold">&#34;Found an id in range: {}&#34;</span>, id_variable)
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    Message::Hello { id: <span style="color:#ff0;font-weight:bold">10</span>..=<span style="color:#ff0;font-weight:bold">12</span> } =&gt; {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#0ff;font-weight:bold">&#34;Found an id in another range&#34;</span>)
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    Message::Hello { id } =&gt; {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#0ff;font-weight:bold">&#34;Found some other id: {}&#34;</span>, id)
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>@绑定可以在模式中测试一个值的同时将它绑定到变量中。（在范围匹配时，只能使用右关闭的模式）</p>
<h3 id="解构赋值">解构赋值</h3>
<p>这一模式可以用来<strong>分解结构体、枚举、元组或引用，从而使用这些值中的不同部分</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> Point {
</span></span><span style="display:flex;"><span>    x: <span style="color:#fff;font-weight:bold">i32</span>,
</span></span><span style="display:flex;"><span>    y: <span style="color:#fff;font-weight:bold">i32</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> p = Point{x:<span style="color:#ff0;font-weight:bold">1</span>, y:<span style="color:#ff0;font-weight:bold">2</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">let</span> Point { x: a, y: b } = p; <span style="color:#007f7f">// 自动生成a和b的值，对应x和y
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    assert_eq!(a, <span style="color:#ff0;font-weight:bold">1</span>);
</span></span><span style="display:flex;"><span>    assert_eq!(b, <span style="color:#ff0;font-weight:bold">2</span>);
</span></span><span style="display:flex;"><span>  	<span style="color:#007f7f">// 或者使用更简洁的同名字段
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">let</span> Point{x, y} = p;
</span></span><span style="display:flex;"><span>    assert_eq!(x, <span style="color:#ff0;font-weight:bold">1</span>);
</span></span><span style="display:flex;"><span>    assert_eq!(y, <span style="color:#ff0;font-weight:bold">2</span>);
</span></span><span style="display:flex;"><span>  	<span style="color:#007f7f">// 或者在match中
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  	<span style="color:#fff;font-weight:bold">match</span> p {
</span></span><span style="display:flex;"><span>        Point { x, y: <span style="color:#ff0;font-weight:bold">0</span> } =&gt; println!(<span style="color:#0ff;font-weight:bold">&#34;on the x axis at {}&#34;</span>, x),
</span></span><span style="display:flex;"><span>        Point { x: <span style="color:#ff0;font-weight:bold">0</span>, y } =&gt; println!(<span style="color:#0ff;font-weight:bold">&#34;on the y axis at {}&#34;</span>, y),
</span></span><span style="display:flex;"><span>        Point { x, y } =&gt; print!(<span style="color:#0ff;font-weight:bold">&#34;other at ({}, {})&#34;</span>, x, y),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>枚举：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">enum</span> Message {
</span></span><span style="display:flex;"><span>    Quit,
</span></span><span style="display:flex;"><span>    Move { x: <span style="color:#fff;font-weight:bold">i32</span>, y: <span style="color:#fff;font-weight:bold">i32</span> },
</span></span><span style="display:flex;"><span>    Write(<span style="color:#fff;font-weight:bold">String</span>),
</span></span><span style="display:flex;"><span>    ChangeColor(<span style="color:#fff;font-weight:bold">i32</span>, <span style="color:#fff;font-weight:bold">i32</span>, <span style="color:#fff;font-weight:bold">i32</span>),
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span> <span style="color:#fff;font-weight:bold">let</span> msg = Message::ChangeColor(<span style="color:#ff0;font-weight:bold">0</span>, <span style="color:#ff0;font-weight:bold">160</span>, <span style="color:#ff0;font-weight:bold">255</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">match</span> msg {
</span></span><span style="display:flex;"><span>      Message::Quit =&gt; {
</span></span><span style="display:flex;"><span>            println!(<span style="color:#0ff;font-weight:bold">&#34;The Quit variant has no data to destructure.&#34;</span>)
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>      Message::Move { x, y } =&gt; {
</span></span><span style="display:flex;"><span>            println!(
</span></span><span style="display:flex;"><span>                <span style="color:#0ff;font-weight:bold">&#34;Move in the x direction {} and in the y direction {}&#34;</span>,
</span></span><span style="display:flex;"><span>                x,
</span></span><span style="display:flex;"><span>                y
</span></span><span style="display:flex;"><span>            );
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      Message::Write(text) =&gt; println!(<span style="color:#0ff;font-weight:bold">&#34;Text message: {}&#34;</span>, text),
</span></span><span style="display:flex;"><span>      Message::ChangeColor(r, g, b) =&gt; {
</span></span><span style="display:flex;"><span>            println!(
</span></span><span style="display:flex;"><span>                <span style="color:#0ff;font-weight:bold">&#34;Change the color to red {}, green {}, and blue {}&#34;</span>,
</span></span><span style="display:flex;"><span>                r,
</span></span><span style="display:flex;"><span>                g,
</span></span><span style="display:flex;"><span>                b
</span></span><span style="display:flex;"><span>            )
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="忽略值">忽略值</h3>
<p>使用下划线<code>_</code>来忽略整个值或者元组中的某个值。</p>
<p>下换线<code>_</code>不会绑定值。</p>
<p>rust对没有引用的变量、枚举、函数等会进行warning，使用下划线开头可避免warning。但是这种变量仍会获取所有权。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>let a = 3;
</span></span><span style="display:flex;"><span>let _b = a;
</span></span></code></pre></div><p>使用<code>..</code>忽略剩余部分。<code>..</code>会自动展开并填充所需值。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> origin = Point { x: <span style="color:#ff0;font-weight:bold">0</span>, y: <span style="color:#ff0;font-weight:bold">0</span>, z: <span style="color:#ff0;font-weight:bold">0</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">match</span> origin {
</span></span><span style="display:flex;"><span>    Point { x, .. } =&gt; println!(<span style="color:#0ff;font-weight:bold">&#34;x is {}&#34;</span>, x),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="版本控制">版本控制</h2>
<p>当你第一次构建项目时，Cargo会依次遍历我们声明的依赖及其对应的语义化版本，找到符合要求的具体版本号，并将它们写入Cargo.lock文件中。随后再次构建项目时，Cargo就会优先检索Cargo.lock
，假如文件中存在已经指明具体版本的依赖库，那么它就会跳过计算版本号的过程，并直接使用文件中指明的版本。这使得我们拥有了一个自动化的、可重现的构建系统。</p>
<p>当你确实想要升级某个依赖包时，Cargo提供了一个专用命令：update，它会强制Cargo忽略Cargo.lock
文件，并重新计算出所有依赖包中符合Cargo.toml声明的最新版本。假如命令运行成功，Cargo就会将更新后的版本号写入Cargo.lock文件，并覆盖之前的内容。</p>
<h2 id="其他">其他</h2>
<h3 id="doc">doc</h3>
<p>你当然无法在使用第三方包时凭空知晓自己究竟需要使用什么样的trait或什么样的函数，而是需要在各类包的文档中找到相关的使用说明。值得一提的是，Cargo提供了一个特别有用的命令：cargo doc &ndash;open，它可以为你在本地构建一份有关所有依赖的文档，并自动地在浏览器中将文档打开来供你查阅</p>
<h2 id="资料">资料</h2>
<ul>
<li><a href="https://play.rust-lang.org">rust在线编辑器</a></li>
</ul>

  </article>
</section>

  

      </div>

      
  <footer class="footer">
    <section class="container">
      
        <p>夭寿不贰，修身以俟</p>
      
      
        ©
        
          2021 -
        
        2023
        
      
      
         · 
         <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
      
      
    </section>
  </footer>


    </main>

    
      
        
        <script src="/js/dark-mode.min.c2d8a1f8f2660e4a46d776277c72695a1e0ca65939d79f754441d47551604af5.js"></script>
      
    

    

    

    

    

    

    

    
  </body>

</html>
