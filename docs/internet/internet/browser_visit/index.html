<!DOCTYPE html>
<html lang="zh">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Language" content="zh">
    

    
    <meta name="description" content="浏览器访问网址的过程就是客户端（浏览器）和服务端进行数据交换的过程。这个过程大概是：
浏览器将域名转换为IP 浏览器将请求信息打包通过TCP协议进行传输 网络层、数据链路层、物理层之间的数据交换 代理服务器接收请求并转发到后端服务器 后端服务器进行逻辑与数据处理，向代理服务器发送响应数据 代理服务器向客户端发送数据 浏览器收到数据后进行渲染 根据域名查找IP（DNS） 为了方便人们记忆，网站往往都会申请一个域名，而网络层使用IP地址作为目的地标识，因为需要将域名转化为IP。查询流程如下：
先查找浏览器的程序内存，如果未找到，执行下一步 查找操作系统缓存，如果未找到，执行下一步 查找本地的host文件，如果未找到，执行下一步 通过域名系统查找，如果未找到，执行下一步 浏览器停止请求并返回错误信息（默认会重试4次） 域名系统是一个层级的分布式系统，最顶层为根域名，每台计算机上都会记录根域名地址。
当计算机在本地找不到域名对应的IP后，会向本地域名服务器发起请求。如果本地域名服务器也不知道，就会将请求转发到根域名服务器。请求会从根域名服务器开始一层一层向下转发，直到找到目标域名。找到目标域名后，请求途径的各个服务器都会将其数据放入本地的缓存中，以便下次使用。
打包数据（HTTP） 浏览器会将请求所需的数据打包，然后提供给操作系统的TCP协议栈。
需要打包的数据往往包括：
请求地址 请求方法 请求体 请求头，请求头内是协议定义的控制信息，如：User-Agent、Host、Accept、Accept-Encoding等 这些数据会按照应用层协议（HTTP）进行组装、编码，然后将数据包提供给操作系统的TCP协议栈，由TCP协议栈进一步处理，并由其负责数据传输。
建立套接字（socket） 套接字是连接应用程序与网络协议栈的接口，服务端与客户端通过两端的套接字形成了一条连接，两端的数据通过这条连接进行传输。
客户端在发起请求时建立套接字，但服务端必须在客户端发起请求前建立好套接字。
套接字是一块存放控制信息的内存空间，这些控制信息包括：IP地址、端口号、状态等。
服务端在创建后，就会创建套接字来监听、等待客户端的连接请求。客户端在发起请求时也会先创建套接字，然后通过套接字发起请求。
TCP协议栈 TCP协议栈在收到发送数据请求后，会根据套接字的状态信息判断当前连接的状态。
如果当前未建立连接，则会先进行“三次握手”。
如果已建立连接，则会将应用层的数据放到“发送缓冲区”，TCP协议栈会根据当前的网络状态（拥塞控制）、服务端的通告窗口（滑动窗口）、数据包的大小（是否超过MSS）、系统设置（是否开启Nagle算法）等来判断在何时发送。
数据链路层与网络层 适配器（网卡） 适配器是计算机中负责与局域网通信的接口。
当适配器收到有差错的帧时，就把这个帧直接丢弃而不必通知计算机。当适配器收到正确的帧时，它就使用中断来通知该计算机，并交付协议栈中的网络层。
当计算机要发送IP数据报时，就由协议栈把IP数据报向下交给适配器，组装成帧后发送到局域网。
路由器 路由器的作用是找到目的主机。路由器内部会维持一张路由表，通过这张路由表可以找到下一跳要访问的路由器。
访问步骤如下：
从数据报的首部提取目的主机的IP地址，从而获得网络地址 如果网络地址就是此路由器直接相连的某个网络地址，则将数据报直接交付给目的主机；否则执行下一步 如果路由表中有到达目的主机的IP地址的特定路由，则将数据报传送给路由表中指定的特定路由；否则执行下一步 若果路由表中有到达目的主机的网络地址的路由，则将数据包传送给路由表中对应的下一跳路由器；否则执行下一步 如果路由表中有一个默认路由，则把数据报传送给默认路由器；否则报告转发分组出错。 由此可见，数据报需要在路由器中一次次转发，直到目的路由器。目的路由器会将数据报发给目的主机。
当路由器收到一个待转发的数据报后，会从路由表中找到下一条路由器的IP地址，然后通过ARP协议（会先查找本地ARP缓存）找到其对应的MAC地址，并将MAC地址放到链路层MAC帧的首部，然后根据这个硬件地址找到下一个路由器。
企业内为了方便管理网络，往往会划分子网，此时路由器的转发规则为：
从数据报的首部提取目的主机的IP地址，从而获得网络地址 判断是否为直接交付：对路由器直接相连的网络逐个进行检查，用各网络的子网掩码和目的主机的网络地址逐位相与，如果相应的网络地址和结果匹配，那么就直接进行交付；否则执行下一步 如果路由表中有到达目的主机的IP地址的特定路由，则将数据报传送给路由表中指定的特定路由；否则执行下一步 对路由器中的每一行（目的网络地址、子网掩码、下一跳地址），用其中的子网掩码和目的主机的网络地址逐位相与，如果结果和该行的目的网络地址匹配，则把数据报传送给路由表中对应的下一跳路由器；否则执行下一步 如果路由表中有一个默认路由，则把数据报传送给默认路由器；否则报告转发分组出错。 交换机 通过路由器找到了目的主机的MAC地址，还需要通过交换机使用MAC地址找到目的主机。
交换机在内部维持了一张MAC地址表，通过这张表来将数据包传送到目的端口。
服务端 代理服务器 后端服务器的流量往往由代理服务器（如NGINX）进行代理，其优点是能够高效、稳定的处理并发请求。
代理服务器负责将流量分发到后端节点，在并发量特别大的情况下，还会在代理服务器之前通过负载均衡器进一步分发流量。
后端服务 后端服务接收到请求后，解析出请求信息，并进行对应的处理。
在HTTP协议中，通过请求方法和路径来标识一种请求（通过trie树来快速匹配路径）。
后端服务对请求进行逻辑和数据处理中，往往会使用大量的中间件（Mysql、Redis、Kafka等）。
处理完后，按照“约定”组装数据，并通过反向代理服务器返回结果。">
    <meta name="keywords" content="">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="在浏览器访问一个网址都经历了哪些"/>
<meta name="twitter:description" content="浏览器访问网址的过程就是客户端（浏览器）和服务端进行数据交换的过程。这个过程大概是：
浏览器将域名转换为IP 浏览器将请求信息打包通过TCP协议进行传输 网络层、数据链路层、物理层之间的数据交换 代理服务器接收请求并转发到后端服务器 后端服务器进行逻辑与数据处理，向代理服务器发送响应数据 代理服务器向客户端发送数据 浏览器收到数据后进行渲染 根据域名查找IP（DNS） 为了方便人们记忆，网站往往都会申请一个域名，而网络层使用IP地址作为目的地标识，因为需要将域名转化为IP。查询流程如下：
先查找浏览器的程序内存，如果未找到，执行下一步 查找操作系统缓存，如果未找到，执行下一步 查找本地的host文件，如果未找到，执行下一步 通过域名系统查找，如果未找到，执行下一步 浏览器停止请求并返回错误信息（默认会重试4次） 域名系统是一个层级的分布式系统，最顶层为根域名，每台计算机上都会记录根域名地址。
当计算机在本地找不到域名对应的IP后，会向本地域名服务器发起请求。如果本地域名服务器也不知道，就会将请求转发到根域名服务器。请求会从根域名服务器开始一层一层向下转发，直到找到目标域名。找到目标域名后，请求途径的各个服务器都会将其数据放入本地的缓存中，以便下次使用。
打包数据（HTTP） 浏览器会将请求所需的数据打包，然后提供给操作系统的TCP协议栈。
需要打包的数据往往包括：
请求地址 请求方法 请求体 请求头，请求头内是协议定义的控制信息，如：User-Agent、Host、Accept、Accept-Encoding等 这些数据会按照应用层协议（HTTP）进行组装、编码，然后将数据包提供给操作系统的TCP协议栈，由TCP协议栈进一步处理，并由其负责数据传输。
建立套接字（socket） 套接字是连接应用程序与网络协议栈的接口，服务端与客户端通过两端的套接字形成了一条连接，两端的数据通过这条连接进行传输。
客户端在发起请求时建立套接字，但服务端必须在客户端发起请求前建立好套接字。
套接字是一块存放控制信息的内存空间，这些控制信息包括：IP地址、端口号、状态等。
服务端在创建后，就会创建套接字来监听、等待客户端的连接请求。客户端在发起请求时也会先创建套接字，然后通过套接字发起请求。
TCP协议栈 TCP协议栈在收到发送数据请求后，会根据套接字的状态信息判断当前连接的状态。
如果当前未建立连接，则会先进行“三次握手”。
如果已建立连接，则会将应用层的数据放到“发送缓冲区”，TCP协议栈会根据当前的网络状态（拥塞控制）、服务端的通告窗口（滑动窗口）、数据包的大小（是否超过MSS）、系统设置（是否开启Nagle算法）等来判断在何时发送。
数据链路层与网络层 适配器（网卡） 适配器是计算机中负责与局域网通信的接口。
当适配器收到有差错的帧时，就把这个帧直接丢弃而不必通知计算机。当适配器收到正确的帧时，它就使用中断来通知该计算机，并交付协议栈中的网络层。
当计算机要发送IP数据报时，就由协议栈把IP数据报向下交给适配器，组装成帧后发送到局域网。
路由器 路由器的作用是找到目的主机。路由器内部会维持一张路由表，通过这张路由表可以找到下一跳要访问的路由器。
访问步骤如下：
从数据报的首部提取目的主机的IP地址，从而获得网络地址 如果网络地址就是此路由器直接相连的某个网络地址，则将数据报直接交付给目的主机；否则执行下一步 如果路由表中有到达目的主机的IP地址的特定路由，则将数据报传送给路由表中指定的特定路由；否则执行下一步 若果路由表中有到达目的主机的网络地址的路由，则将数据包传送给路由表中对应的下一跳路由器；否则执行下一步 如果路由表中有一个默认路由，则把数据报传送给默认路由器；否则报告转发分组出错。 由此可见，数据报需要在路由器中一次次转发，直到目的路由器。目的路由器会将数据报发给目的主机。
当路由器收到一个待转发的数据报后，会从路由表中找到下一条路由器的IP地址，然后通过ARP协议（会先查找本地ARP缓存）找到其对应的MAC地址，并将MAC地址放到链路层MAC帧的首部，然后根据这个硬件地址找到下一个路由器。
企业内为了方便管理网络，往往会划分子网，此时路由器的转发规则为：
从数据报的首部提取目的主机的IP地址，从而获得网络地址 判断是否为直接交付：对路由器直接相连的网络逐个进行检查，用各网络的子网掩码和目的主机的网络地址逐位相与，如果相应的网络地址和结果匹配，那么就直接进行交付；否则执行下一步 如果路由表中有到达目的主机的IP地址的特定路由，则将数据报传送给路由表中指定的特定路由；否则执行下一步 对路由器中的每一行（目的网络地址、子网掩码、下一跳地址），用其中的子网掩码和目的主机的网络地址逐位相与，如果结果和该行的目的网络地址匹配，则把数据报传送给路由表中对应的下一跳路由器；否则执行下一步 如果路由表中有一个默认路由，则把数据报传送给默认路由器；否则报告转发分组出错。 交换机 通过路由器找到了目的主机的MAC地址，还需要通过交换机使用MAC地址找到目的主机。
交换机在内部维持了一张MAC地址表，通过这张表来将数据包传送到目的端口。
服务端 代理服务器 后端服务器的流量往往由代理服务器（如NGINX）进行代理，其优点是能够高效、稳定的处理并发请求。
代理服务器负责将流量分发到后端节点，在并发量特别大的情况下，还会在代理服务器之前通过负载均衡器进一步分发流量。
后端服务 后端服务接收到请求后，解析出请求信息，并进行对应的处理。
在HTTP协议中，通过请求方法和路径来标识一种请求（通过trie树来快速匹配路径）。
后端服务对请求进行逻辑和数据处理中，往往会使用大量的中间件（Mysql、Redis、Kafka等）。
处理完后，按照“约定”组装数据，并通过反向代理服务器返回结果。"/>

    <meta property="og:title" content="在浏览器访问一个网址都经历了哪些" />
<meta property="og:description" content="浏览器访问网址的过程就是客户端（浏览器）和服务端进行数据交换的过程。这个过程大概是：
浏览器将域名转换为IP 浏览器将请求信息打包通过TCP协议进行传输 网络层、数据链路层、物理层之间的数据交换 代理服务器接收请求并转发到后端服务器 后端服务器进行逻辑与数据处理，向代理服务器发送响应数据 代理服务器向客户端发送数据 浏览器收到数据后进行渲染 根据域名查找IP（DNS） 为了方便人们记忆，网站往往都会申请一个域名，而网络层使用IP地址作为目的地标识，因为需要将域名转化为IP。查询流程如下：
先查找浏览器的程序内存，如果未找到，执行下一步 查找操作系统缓存，如果未找到，执行下一步 查找本地的host文件，如果未找到，执行下一步 通过域名系统查找，如果未找到，执行下一步 浏览器停止请求并返回错误信息（默认会重试4次） 域名系统是一个层级的分布式系统，最顶层为根域名，每台计算机上都会记录根域名地址。
当计算机在本地找不到域名对应的IP后，会向本地域名服务器发起请求。如果本地域名服务器也不知道，就会将请求转发到根域名服务器。请求会从根域名服务器开始一层一层向下转发，直到找到目标域名。找到目标域名后，请求途径的各个服务器都会将其数据放入本地的缓存中，以便下次使用。
打包数据（HTTP） 浏览器会将请求所需的数据打包，然后提供给操作系统的TCP协议栈。
需要打包的数据往往包括：
请求地址 请求方法 请求体 请求头，请求头内是协议定义的控制信息，如：User-Agent、Host、Accept、Accept-Encoding等 这些数据会按照应用层协议（HTTP）进行组装、编码，然后将数据包提供给操作系统的TCP协议栈，由TCP协议栈进一步处理，并由其负责数据传输。
建立套接字（socket） 套接字是连接应用程序与网络协议栈的接口，服务端与客户端通过两端的套接字形成了一条连接，两端的数据通过这条连接进行传输。
客户端在发起请求时建立套接字，但服务端必须在客户端发起请求前建立好套接字。
套接字是一块存放控制信息的内存空间，这些控制信息包括：IP地址、端口号、状态等。
服务端在创建后，就会创建套接字来监听、等待客户端的连接请求。客户端在发起请求时也会先创建套接字，然后通过套接字发起请求。
TCP协议栈 TCP协议栈在收到发送数据请求后，会根据套接字的状态信息判断当前连接的状态。
如果当前未建立连接，则会先进行“三次握手”。
如果已建立连接，则会将应用层的数据放到“发送缓冲区”，TCP协议栈会根据当前的网络状态（拥塞控制）、服务端的通告窗口（滑动窗口）、数据包的大小（是否超过MSS）、系统设置（是否开启Nagle算法）等来判断在何时发送。
数据链路层与网络层 适配器（网卡） 适配器是计算机中负责与局域网通信的接口。
当适配器收到有差错的帧时，就把这个帧直接丢弃而不必通知计算机。当适配器收到正确的帧时，它就使用中断来通知该计算机，并交付协议栈中的网络层。
当计算机要发送IP数据报时，就由协议栈把IP数据报向下交给适配器，组装成帧后发送到局域网。
路由器 路由器的作用是找到目的主机。路由器内部会维持一张路由表，通过这张路由表可以找到下一跳要访问的路由器。
访问步骤如下：
从数据报的首部提取目的主机的IP地址，从而获得网络地址 如果网络地址就是此路由器直接相连的某个网络地址，则将数据报直接交付给目的主机；否则执行下一步 如果路由表中有到达目的主机的IP地址的特定路由，则将数据报传送给路由表中指定的特定路由；否则执行下一步 若果路由表中有到达目的主机的网络地址的路由，则将数据包传送给路由表中对应的下一跳路由器；否则执行下一步 如果路由表中有一个默认路由，则把数据报传送给默认路由器；否则报告转发分组出错。 由此可见，数据报需要在路由器中一次次转发，直到目的路由器。目的路由器会将数据报发给目的主机。
当路由器收到一个待转发的数据报后，会从路由表中找到下一条路由器的IP地址，然后通过ARP协议（会先查找本地ARP缓存）找到其对应的MAC地址，并将MAC地址放到链路层MAC帧的首部，然后根据这个硬件地址找到下一个路由器。
企业内为了方便管理网络，往往会划分子网，此时路由器的转发规则为：
从数据报的首部提取目的主机的IP地址，从而获得网络地址 判断是否为直接交付：对路由器直接相连的网络逐个进行检查，用各网络的子网掩码和目的主机的网络地址逐位相与，如果相应的网络地址和结果匹配，那么就直接进行交付；否则执行下一步 如果路由表中有到达目的主机的IP地址的特定路由，则将数据报传送给路由表中指定的特定路由；否则执行下一步 对路由器中的每一行（目的网络地址、子网掩码、下一跳地址），用其中的子网掩码和目的主机的网络地址逐位相与，如果结果和该行的目的网络地址匹配，则把数据报传送给路由表中对应的下一跳路由器；否则执行下一步 如果路由表中有一个默认路由，则把数据报传送给默认路由器；否则报告转发分组出错。 交换机 通过路由器找到了目的主机的MAC地址，还需要通过交换机使用MAC地址找到目的主机。
交换机在内部维持了一张MAC地址表，通过这张表来将数据包传送到目的端口。
服务端 代理服务器 后端服务器的流量往往由代理服务器（如NGINX）进行代理，其优点是能够高效、稳定的处理并发请求。
代理服务器负责将流量分发到后端节点，在并发量特别大的情况下，还会在代理服务器之前通过负载均衡器进一步分发流量。
后端服务 后端服务接收到请求后，解析出请求信息，并进行对应的处理。
在HTTP协议中，通过请求方法和路径来标识一种请求（通过trie树来快速匹配路径）。
后端服务对请求进行逻辑和数据处理中，往往会使用大量的中间件（Mysql、Redis、Kafka等）。
处理完后，按照“约定”组装数据，并通过反向代理服务器返回结果。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://stong1994.github.io/internet/internet/browser_visit/" /><meta property="article:section" content="internet" />
<meta property="article:published_time" content="2022-03-25T15:58:00+08:00" />
<meta property="article:modified_time" content="2022-03-25T15:58:00+08:00" />



    <title>
  在浏览器访问一个网址都经历了哪些 · 北人
</title>

    
      <link rel="canonical" href="https://stong1994.github.io/internet/internet/browser_visit/">
    

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700&display=swap" rel="stylesheet">
    <link rel="preload" href="/fonts/forkawesome-webfont.woff2?v=1.1.7" as="font" type="font/woff2" crossorigin>

    
      
      
      <link rel="stylesheet" href="/css/coder.min.5317d5aa4161466b8ec88da2b36cacd596a0fdc1cc6a986e05f9b413df8ad2d3.css" integrity="sha256-UxfVqkFhRmuOyI2is2ys1Zag/cHMaphuBfm0E9&#43;K0tM=" crossorigin="anonymous" media="screen" />
    

    

    
      
        
        
        <link rel="stylesheet" href="/css/coder-dark.min.126ad3988d46bdae6217a11105b53c9662bca05f39d42d3c0fb366919d334620.css" integrity="sha256-EmrTmI1Gva5iF6ERBbU8lmK8oF851C08D7NmkZ0zRiA=" crossorigin="anonymous" media="screen" />
      
    

    

    

    <link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

    <link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

    
      <script defer src="https://twemoji.maxcdn.com/v/13.0.1/twemoji.min.js"
        integrity="sha384-5f4X0lBluNY/Ib4VhGx0Pf6iDCF99VGXJIyYy7dDLY5QlEd7Ap0hICSSZA1XYbc4" crossorigin="anonymous"></script>
    

    <meta name="generator" content="Hugo 0.101.0" />
  </head>

  
  
    
  
  <body class="colorscheme-auto"
        onload=" twemoji.parse(document.body); "
  >
    
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      北人
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/internet/">计算机与互联网</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/cloudnative/">云原生</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/web3/">区块链&amp;web3</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/other/">杂谈</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/mental_model/">心智模型</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/about/">关于</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


      <div class="content">
        
    <div id="toc" class="well col-md-4 col-sm-6">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#根据域名查找ipdns">根据域名查找IP（DNS）</a></li>
    <li><a href="#打包数据http">打包数据（HTTP）</a></li>
    <li><a href="#建立套接字socket">建立套接字（socket）</a></li>
    <li><a href="#tcp协议栈">TCP协议栈</a></li>
    <li><a href="#数据链路层与网络层">数据链路层与网络层</a>
      <ul>
        <li><a href="#适配器网卡">适配器（网卡）</a></li>
        <li><a href="#路由器">路由器</a></li>
        <li><a href="#交换机">交换机</a></li>
      </ul>
    </li>
    <li><a href="#服务端">服务端</a>
      <ul>
        <li><a href="#代理服务器">代理服务器</a></li>
        <li><a href="#后端服务">后端服务</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
  <section class="container page">
  <article>
    <header>
      <h1>在浏览器访问一个网址都经历了哪些</h1>
    </header>

    <p>浏览器访问网址的过程就是客户端（浏览器）和服务端进行数据交换的过程。这个过程大概是：</p>
<ol>
<li>浏览器将域名转换为IP</li>
<li>浏览器将请求信息打包通过TCP协议进行传输</li>
<li>网络层、数据链路层、物理层之间的数据交换</li>
<li>代理服务器接收请求并转发到后端服务器</li>
<li>后端服务器进行逻辑与数据处理，向代理服务器发送响应数据</li>
<li>代理服务器向客户端发送数据</li>
<li>浏览器收到数据后进行渲染</li>
</ol>
<h2 id="根据域名查找ipdns">根据域名查找IP（DNS）</h2>
<p>为了方便人们记忆，网站往往都会申请一个域名，而网络层使用IP地址作为目的地标识，因为需要将域名转化为IP。查询流程如下：</p>
<ol>
<li>先查找浏览器的程序内存，如果未找到，执行下一步</li>
<li>查找操作系统缓存，如果未找到，执行下一步</li>
<li>查找本地的host文件，如果未找到，执行下一步</li>
<li>通过域名系统查找，如果未找到，执行下一步</li>
<li>浏览器停止请求并返回错误信息（默认会重试4次）</li>
</ol>
<p>域名系统是一个层级的分布式系统，最顶层为根域名，每台计算机上都会记录根域名地址。</p>
<p>当计算机在本地找不到域名对应的IP后，会向<strong>本地域名服务器</strong>发起请求。如果<strong>本地域名服务器</strong>也不知道，就会将请求转发到<strong>根域名服务器</strong>。请求会从根域名服务器开始一层一层<strong>向下转发</strong>，直到找到目标域名。找到目标域名后，请求途径的各个服务器都会将其数据放入本地的<strong>缓存</strong>中，以便下次使用。</p>
<h2 id="打包数据http">打包数据（HTTP）</h2>
<p>浏览器会将请求所需的数据打包，然后提供给操作系统的TCP协议栈。</p>
<p>需要打包的数据往往包括：</p>
<ol>
<li>请求地址</li>
<li>请求方法</li>
<li>请求体</li>
<li>请求头，请求头内是协议定义的控制信息，如：User-Agent、Host、Accept、Accept-Encoding等</li>
</ol>
<p>这些数据会按照应用层协议（HTTP）进行组装、编码，然后将数据包提供给操作系统的TCP协议栈，由TCP协议栈进一步处理，并由其负责数据传输。</p>
<h2 id="建立套接字socket">建立套接字（socket）</h2>
<p><strong>套接字是连接应用程序与网络协议栈的接口</strong>，服务端与客户端通过两端的套接字形成了一条连接，两端的数据通过这条连接进行传输。</p>
<p>客户端在发起请求时建立套接字，但服务端必须在客户端发起请求前建立好套接字。</p>
<p><strong>套接字是一块存放控制信息的内存空间</strong>，这些控制信息包括：IP地址、端口号、状态等。</p>
<p>服务端在创建后，就会创建套接字来监听、等待客户端的连接请求。客户端在发起请求时也会先创建套接字，然后通过套接字发起请求。</p>
<h2 id="tcp协议栈">TCP协议栈</h2>
<p>TCP协议栈在收到发送数据请求后，会根据套接字的状态信息判断当前连接的状态。</p>
<p>如果当前未建立连接，则会先进行“三次握手”。</p>
<p>如果已建立连接，则会将应用层的数据放到“发送缓冲区”，TCP协议栈会根据当前的网络状态（<strong>拥塞控制</strong>）、服务端的通告窗口（<strong>滑动窗口</strong>）、数据包的大小（是否超过<strong>MSS</strong>）、系统设置（是否开启<strong>Nagle算法</strong>）等来判断在何时发送。</p>
<h2 id="数据链路层与网络层">数据链路层与网络层</h2>
<h3 id="适配器网卡">适配器（网卡）</h3>
<p>适配器是计算机中负责与局域网通信的接口。</p>
<p>当适配器收到有差错的帧时，就把这个帧直接丢弃而不必通知计算机。当适配器收到正确的帧时，它就使用中断来通知该计算机，并交付协议栈中的网络层。</p>
<p>当计算机要发送IP数据报时，就由协议栈把IP数据报向下交给适配器，组装成帧后发送到局域网。</p>
<h3 id="路由器">路由器</h3>
<p>路由器的作用是找到目的主机。路由器内部会维持一张路由表，通过这张路由表可以找到下一跳要访问的路由器。</p>
<p>访问步骤如下：</p>
<ol>
<li>从数据报的首部提取目的主机的IP地址，从而获得网络地址</li>
<li>如果网络地址就是此路由器直接相连的某个网络地址，则将数据报直接交付给目的主机；否则执行下一步</li>
<li>如果路由表中有到达目的主机的IP地址的特定路由，则将数据报传送给路由表中指定的特定路由；否则执行下一步</li>
<li>若果路由表中有到达目的主机的网络地址的路由，则将数据包传送给路由表中对应的下一跳路由器；否则执行下一步</li>
<li>如果路由表中有一个默认路由，则把数据报传送给默认路由器；否则报告转发分组出错。</li>
</ol>
<p>由此可见，数据报需要在路由器中一次次转发，直到目的路由器。目的路由器会将数据报发给目的主机。</p>
<p>当路由器收到一个待转发的数据报后，会从路由表中找到下一条路由器的IP地址，然后通过ARP协议（会先查找本地ARP缓存）找到其对应的MAC地址，并将MAC地址放到链路层MAC帧的首部，然后根据这个硬件地址找到下一个路由器。</p>
<p>企业内为了方便管理网络，往往会划分<strong>子网</strong>，此时路由器的转发规则为：</p>
<ol>
<li>从数据报的首部提取目的主机的IP地址，从而获得网络地址</li>
<li>判断是否为直接交付：对路由器直接相连的网络逐个进行检查，用各网络的子网掩码和目的主机的网络地址逐位相与，如果相应的网络地址和结果匹配，那么就直接进行交付；否则执行下一步</li>
<li>如果路由表中有到达目的主机的IP地址的特定路由，则将数据报传送给路由表中指定的特定路由；否则执行下一步</li>
<li>对路由器中的每一行（目的网络地址、子网掩码、下一跳地址），用其中的子网掩码和目的主机的网络地址逐位相与，如果结果和该行的目的网络地址匹配，则把数据报传送给路由表中对应的下一跳路由器；否则执行下一步</li>
<li>如果路由表中有一个默认路由，则把数据报传送给默认路由器；否则报告转发分组出错。</li>
</ol>
<h3 id="交换机">交换机</h3>
<p>通过路由器找到了目的主机的MAC地址，还需要通过交换机使用MAC地址找到目的主机。</p>
<p>交换机在内部维持了一张MAC地址表，通过这张表来将数据包传送到目的端口。</p>
<h2 id="服务端">服务端</h2>
<h3 id="代理服务器">代理服务器</h3>
<p>后端服务器的流量往往由代理服务器（如NGINX）进行代理，其优点是能够高效、稳定的处理并发请求。</p>
<p>代理服务器负责将流量分发到后端节点，在并发量特别大的情况下，还会在代理服务器之前通过负载均衡器进一步分发流量。</p>
<h3 id="后端服务">后端服务</h3>
<p>后端服务接收到请求后，解析出请求信息，并进行对应的处理。</p>
<p>在HTTP协议中，通过<strong>请求方法</strong>和<strong>路径</strong>来标识一种请求（通过<strong>trie树</strong>来快速匹配路径）。</p>
<p>后端服务对请求进行逻辑和数据处理中，往往会使用大量的<strong>中间件</strong>（Mysql、Redis、Kafka等）。</p>
<p>处理完后，按照“约定”组装数据，并通过反向代理服务器返回结果。</p>

  </article>
</section>

  

      </div>

      
  <footer class="footer">
    <section class="container">
      
        <p>夭寿不贰，修身以俟</p>
      
      
        ©
        
          2021 -
        
        2022
        
      
      
         · 
         <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
      
      
    </section>
  </footer>


    </main>

    
      
        
        <script src="/js/dark-mode.min.c2d8a1f8f2660e4a46d776277c72695a1e0ca65939d79f754441d47551604af5.js"></script>
      
    

    

    

    

    

    

    

    
  </body>

</html>
