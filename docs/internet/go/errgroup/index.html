<!DOCTYPE html>
<html lang="zh">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Language" content="zh">
    

    
    <meta name="description" content="前瞻 在工作中，如果遇到需要并发访问，并且接受返回值的功能，一般都是使用sync.WaitGroup&#43;channel来实现。
但go社区中已经提供了这个功能的封装——errgroup.
虽然errgroup这个轮子和我们自己造的轮子差不多，但是既然别人已经造好了，我们就没必要再重复造轮子了。
源码 源码非常简洁，算上注释也才100来行。源码位置：golang.org/x/sync/errgroup
Group // A Group is a collection of goroutines working on subtasks that are part of // the same overall task. // // A zero Group is valid, has no limit on the number of active goroutines, // and does not cancel on error. type Group struct { cancel func() wg sync.WaitGroup sem chan token errOnce sync.Once err error } Group结构非常简单：
cancel：取消函数，并发请求一般都会使用带cancel的context，能非常方便的控制并发中的请求生命周期。 wg: 并发中最常用的组件，用于等待异步任务完成。 sem：一个用于控制并发数量的channel，token的数据类型是一个空结构体（空结构体的好处是不占内存）。 errOnce: 一个只执行一次的并发控制器，由命名可以推断出并发中的错误只会捕获一次。 err: 存储error sem sem是一个非常巧妙的设计，一般控制并发数量，可以使用一个原子值来记录当前的并发数，使用锁来控制请求。errgroup中使用了channel来实现了这个功能。我们看下他的用法。">
    <meta name="keywords" content="">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="go设计之errgroup"/>
<meta name="twitter:description" content="前瞻 在工作中，如果遇到需要并发访问，并且接受返回值的功能，一般都是使用sync.WaitGroup&#43;channel来实现。
但go社区中已经提供了这个功能的封装——errgroup.
虽然errgroup这个轮子和我们自己造的轮子差不多，但是既然别人已经造好了，我们就没必要再重复造轮子了。
源码 源码非常简洁，算上注释也才100来行。源码位置：golang.org/x/sync/errgroup
Group // A Group is a collection of goroutines working on subtasks that are part of // the same overall task. // // A zero Group is valid, has no limit on the number of active goroutines, // and does not cancel on error. type Group struct { cancel func() wg sync.WaitGroup sem chan token errOnce sync.Once err error } Group结构非常简单：
cancel：取消函数，并发请求一般都会使用带cancel的context，能非常方便的控制并发中的请求生命周期。 wg: 并发中最常用的组件，用于等待异步任务完成。 sem：一个用于控制并发数量的channel，token的数据类型是一个空结构体（空结构体的好处是不占内存）。 errOnce: 一个只执行一次的并发控制器，由命名可以推断出并发中的错误只会捕获一次。 err: 存储error sem sem是一个非常巧妙的设计，一般控制并发数量，可以使用一个原子值来记录当前的并发数，使用锁来控制请求。errgroup中使用了channel来实现了这个功能。我们看下他的用法。"/>

    <meta property="og:title" content="go设计之errgroup" />
<meta property="og:description" content="前瞻 在工作中，如果遇到需要并发访问，并且接受返回值的功能，一般都是使用sync.WaitGroup&#43;channel来实现。
但go社区中已经提供了这个功能的封装——errgroup.
虽然errgroup这个轮子和我们自己造的轮子差不多，但是既然别人已经造好了，我们就没必要再重复造轮子了。
源码 源码非常简洁，算上注释也才100来行。源码位置：golang.org/x/sync/errgroup
Group // A Group is a collection of goroutines working on subtasks that are part of // the same overall task. // // A zero Group is valid, has no limit on the number of active goroutines, // and does not cancel on error. type Group struct { cancel func() wg sync.WaitGroup sem chan token errOnce sync.Once err error } Group结构非常简单：
cancel：取消函数，并发请求一般都会使用带cancel的context，能非常方便的控制并发中的请求生命周期。 wg: 并发中最常用的组件，用于等待异步任务完成。 sem：一个用于控制并发数量的channel，token的数据类型是一个空结构体（空结构体的好处是不占内存）。 errOnce: 一个只执行一次的并发控制器，由命名可以推断出并发中的错误只会捕获一次。 err: 存储error sem sem是一个非常巧妙的设计，一般控制并发数量，可以使用一个原子值来记录当前的并发数，使用锁来控制请求。errgroup中使用了channel来实现了这个功能。我们看下他的用法。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://stong1994.github.io/internet/go/errgroup/" /><meta property="article:section" content="internet" />
<meta property="article:published_time" content="2022-10-31T00:01:00+08:00" />
<meta property="article:modified_time" content="2022-10-31T00:01:00+08:00" />



    <title>
  go设计之errgroup · 北人
</title>

    
      <link rel="canonical" href="https://stong1994.github.io/internet/go/errgroup/">
    

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700&display=swap" rel="stylesheet">
    <link rel="preload" href="/fonts/forkawesome-webfont.woff2?v=1.1.7" as="font" type="font/woff2" crossorigin>

    
      
      
      <link rel="stylesheet" href="/css/coder.min.5317d5aa4161466b8ec88da2b36cacd596a0fdc1cc6a986e05f9b413df8ad2d3.css" integrity="sha256-UxfVqkFhRmuOyI2is2ys1Zag/cHMaphuBfm0E9&#43;K0tM=" crossorigin="anonymous" media="screen" />
    

    

    
      
        
        
        <link rel="stylesheet" href="/css/coder-dark.min.126ad3988d46bdae6217a11105b53c9662bca05f39d42d3c0fb366919d334620.css" integrity="sha256-EmrTmI1Gva5iF6ERBbU8lmK8oF851C08D7NmkZ0zRiA=" crossorigin="anonymous" media="screen" />
      
    

    

    

    <link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

    <link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

    
      <script defer src="https://twemoji.maxcdn.com/v/13.0.1/twemoji.min.js"
        integrity="sha384-5f4X0lBluNY/Ib4VhGx0Pf6iDCF99VGXJIyYy7dDLY5QlEd7Ap0hICSSZA1XYbc4" crossorigin="anonymous"></script>
    

    <meta name="generator" content="Hugo 0.101.0" />
  </head>

  
  
    
  
  <body class="colorscheme-auto"
        onload=" twemoji.parse(document.body); "
  >
    
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      北人
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/internet/">计算机与互联网</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/cloudnative/">云原生</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/web3/">区块链&amp;web3</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/book/">读书</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/life/">生活</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/mental_model/">心智模型</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/about/">关于</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


      <div class="content">
        
    <div id="toc" class="well col-md-4 col-sm-6">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#前瞻">前瞻</a></li>
    <li><a href="#源码">源码</a>
      <ul>
        <li><a href="#group">Group</a></li>
        <li><a href="#sem">sem</a></li>
        <li><a href="#withcontext--wait">WithContext &amp; Wait</a></li>
        <li><a href="#go">Go</a></li>
        <li><a href="#example">example</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
  <section class="container page">
  <article>
    <header>
      <h1>go设计之errgroup</h1>
    </header>

    <h2 id="前瞻">前瞻</h2>
<p>在工作中，如果遇到需要并发访问，并且接受返回值的功能，一般都是使用<code>sync.WaitGroup+channel</code>来实现。</p>
<p>但go社区中已经提供了这个功能的封装——<a href="https://pkg.go.dev/golang.org/x/sync/errgroup">errgroup</a>.</p>
<p>虽然errgroup这个轮子和我们自己造的轮子差不多，但是既然别人已经造好了，我们就没必要再重复造轮子了。</p>
<h2 id="源码">源码</h2>
<p>源码非常简洁，算上注释也才100来行。源码位置：<code>golang.org/x/sync/errgroup</code></p>
<h3 id="group">Group</h3>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#007f7f">// A Group is a collection of goroutines working on subtasks that are part of
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// the same overall task.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">//
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// A zero Group is valid, has no limit on the number of active goroutines,
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// and does not cancel on error.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">type</span> Group <span style="color:#fff;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	cancel <span style="color:#fff;font-weight:bold">func</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	wg sync.WaitGroup
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	sem <span style="color:#fff;font-weight:bold">chan</span> token
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	errOnce sync.Once
</span></span><span style="display:flex;"><span>	err     <span style="color:#fff;font-weight:bold">error</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Group结构非常简单：</p>
<ul>
<li>cancel：取消函数，并发请求一般都会使用带cancel的context，能非常方便的控制并发中的请求生命周期。</li>
<li>wg: 并发中最常用的组件，用于等待异步任务完成。</li>
<li>sem：一个用于控制并发数量的channel，token的数据类型是一个空结构体（空结构体的好处是不占内存）。</li>
<li>errOnce: 一个只执行一次的并发控制器，由命名可以推断出并发中的错误只会捕获一次。</li>
<li>err: 存储error</li>
</ul>
<h3 id="sem">sem</h3>
<p>sem是一个非常巧妙的设计，一般控制并发数量，可以使用一个原子值来记录当前的并发数，使用锁来控制请求。errgroup中使用了channel来实现了这个功能。我们看下他的用法。</p>
<h4 id="setlimit-设置并发限制数量">SetLimit-设置并发限制数量</h4>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> (g *Group) SetLimit(n <span style="color:#fff;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">if</span> n &lt; <span style="color:#ff0;font-weight:bold">0</span> {
</span></span><span style="display:flex;"><span>		g.sem = <span style="color:#fff;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">if</span> <span style="color:#fff;font-weight:bold">len</span>(g.sem) != <span style="color:#ff0;font-weight:bold">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">panic</span>(fmt.Errorf(<span style="color:#0ff;font-weight:bold">&#34;errgroup: modify limit while %v goroutines in the group are still active&#34;</span>, <span style="color:#fff;font-weight:bold">len</span>(g.sem)))
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	g.sem = <span style="color:#fff;font-weight:bold">make</span>(<span style="color:#fff;font-weight:bold">chan</span> token, n)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>通过SetLimit来设置并发限制数量，这个数量表现为sem的通道长度。</p>
<p>需要注意的是，如果异步任务已经开始执行，这时候不应该再去设置限制数量（虽然代码里没有对这一要求做非常严谨的判断）。</p>
<h4 id="trygo-判断能否运行任务并执行">TryGo-判断能否运行任务并执行</h4>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> (g *Group) TryGo(f <span style="color:#fff;font-weight:bold">func</span>() <span style="color:#fff;font-weight:bold">error</span>) <span style="color:#fff;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">if</span> g.sem != <span style="color:#fff;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">select</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">case</span> g.sem &lt;- token{}:
</span></span><span style="display:flex;"><span>			<span style="color:#007f7f">// Note: this allows barging iff channels in general allow barging.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>		<span style="color:#fff;font-weight:bold">default</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	g.wg.Add(<span style="color:#ff0;font-weight:bold">1</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">go</span> <span style="color:#fff;font-weight:bold">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">defer</span> g.done()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">if</span> err := f(); err != <span style="color:#fff;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>			g.errOnce.Do(<span style="color:#fff;font-weight:bold">func</span>() {
</span></span><span style="display:flex;"><span>				g.err = err
</span></span><span style="display:flex;"><span>				<span style="color:#fff;font-weight:bold">if</span> g.cancel != <span style="color:#fff;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>					g.cancel()
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			})
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>TryGo其实包含了两个功能：</p>
<ol>
<li>判断当前是否能够执行新任务</li>
<li>如果能执行则执行，不能执行就返回false</li>
</ol>
<p>而能否执行新任务就是判断sem能够立马消费一个token，如果不能的话，说明当前的并发数量已经达到了限制。</p>
<h4 id="done-任务执行完毕的清理工作">done-任务执行完毕的清理工作</h4>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> (g *Group) done() {
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">if</span> g.sem != <span style="color:#fff;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		&lt;-g.sem
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	g.wg.Done()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>done其实就做了两件事：</p>
<ol>
<li>消费sem中的一个token，因为任务开启时一定会存入一个token，因此这里一定能够消费到，并且不会被阻塞。</li>
<li>执行wg.Done()</li>
</ol>
<h3 id="withcontext--wait">WithContext &amp; Wait</h3>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#007f7f">// WithContext returns a new Group and an associated Context derived from ctx.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">//
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// The derived Context is canceled the first time a function passed to Go
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// returns a non-nil error or the first time Wait returns, whichever occurs
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// first.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> WithContext(ctx context.Context) (*Group, context.Context) {
</span></span><span style="display:flex;"><span>	ctx, cancel := context.WithCancel(ctx)
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">return</span> &amp;Group{cancel: cancel}, ctx
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> (g *Group) Wait() <span style="color:#fff;font-weight:bold">error</span> {
</span></span><span style="display:flex;"><span>	g.wg.Wait()
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">if</span> g.cancel != <span style="color:#fff;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		g.cancel()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">return</span> g.err
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>
<p>WithContext是一个创建Group的函数，创建的过程中将ctx封装为带有取消函数的ctx。</p>
</li>
<li>
<p>Wait会等待所有任务执行完毕。</p>
</li>
</ul>
<h3 id="go">Go</h3>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#007f7f">// Go calls the given function in a new goroutine.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// It blocks until the new goroutine can be added without the number of
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// active goroutines in the group exceeding the configured limit.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">//
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// The first call to return a non-nil error cancels the group&#39;s context, if the
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// group was created by calling WithContext. The error will be returned by Wait.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> (g *Group) Go(f <span style="color:#fff;font-weight:bold">func</span>() <span style="color:#fff;font-weight:bold">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">if</span> g.sem != <span style="color:#fff;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		g.sem &lt;- token{}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	g.wg.Add(<span style="color:#ff0;font-weight:bold">1</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">go</span> <span style="color:#fff;font-weight:bold">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">defer</span> g.done()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">if</span> err := f(); err != <span style="color:#fff;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>			g.errOnce.Do(<span style="color:#fff;font-weight:bold">func</span>() {
</span></span><span style="display:flex;"><span>				g.err = err
</span></span><span style="display:flex;"><span>				<span style="color:#fff;font-weight:bold">if</span> g.cancel != <span style="color:#fff;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>					g.cancel()
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			})
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Go与TryGo相似，唯一的区别是如果当前并发数量已经达到限制，则会进行阻塞而不是直接返回。</p>
<h3 id="example">example</h3>
<p>以<code>errgroup_test.go</code>中的一个例子为例：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> ExampleGroup_parallel() {
</span></span><span style="display:flex;"><span>	Google := <span style="color:#fff;font-weight:bold">func</span>(ctx context.Context, query <span style="color:#fff;font-weight:bold">string</span>) ([]Result, <span style="color:#fff;font-weight:bold">error</span>) {
</span></span><span style="display:flex;"><span>		g, ctx := errgroup.WithContext(ctx)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		searches := []Search{Web, Image, Video}
</span></span><span style="display:flex;"><span>		results := <span style="color:#fff;font-weight:bold">make</span>([]Result, <span style="color:#fff;font-weight:bold">len</span>(searches))
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">for</span> i, search := <span style="color:#fff;font-weight:bold">range</span> searches {
</span></span><span style="display:flex;"><span>			i, search := i, search <span style="color:#007f7f">// https://golang.org/doc/faq#closures_and_goroutines
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>			g.Go(<span style="color:#fff;font-weight:bold">func</span>() <span style="color:#fff;font-weight:bold">error</span> {
</span></span><span style="display:flex;"><span>				result, err := search(ctx, query)
</span></span><span style="display:flex;"><span>				<span style="color:#fff;font-weight:bold">if</span> err == <span style="color:#fff;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>					results[i] = result
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#fff;font-weight:bold">return</span> err
</span></span><span style="display:flex;"><span>			})
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">if</span> err := g.Wait(); err != <span style="color:#fff;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">nil</span>, err
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">return</span> results, <span style="color:#fff;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	results, err := Google(context.Background(), <span style="color:#0ff;font-weight:bold">&#34;golang&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">if</span> err != <span style="color:#fff;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		fmt.Fprintln(os.Stderr, err)
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">for</span> _, result := <span style="color:#fff;font-weight:bold">range</span> results {
</span></span><span style="display:flex;"><span>		fmt.Println(result)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#007f7f">// Output:
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#007f7f">// web result for &#34;golang&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#007f7f">// image result for &#34;golang&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#007f7f">// video result for &#34;golang&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}
</span></span></code></pre></div><p>这个例子会并发访问三个地址，然后将结果写入results切片中。需要注意<strong>切片是并发不安全的</strong>，所以在实际开发中，需要对results切片加锁，或者使用channel来传递至。</p>

  </article>
</section>

  

      </div>

      
  <footer class="footer">
    <section class="container">
      
        <p>夭寿不贰，修身以俟</p>
      
      
        ©
        
          2021 -
        
        2022
        
      
      
         · 
         <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
      
      
    </section>
  </footer>


    </main>

    
      
        
        <script src="/js/dark-mode.min.c2d8a1f8f2660e4a46d776277c72695a1e0ca65939d79f754441d47551604af5.js"></script>
      
    

    

    

    

    

    

    

    
  </body>

</html>
