<!DOCTYPE html>
<html lang="zh">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Language" content="zh">
    

    
    <meta name="description" content="一直对MySQL这个黑盒子是如何运行的不甚清楚，因此在这里总结下。
先来了解下MySQL体系架构。
MySQL体系架构 图片来自: https://segmentfault.com/a/1190000039693313
以上图为对照，MySQL的查询会经历大致以下过程：
 客户端与服务端建立连接 查询缓存 将请求的SQL进行解析，并进行语法校验 通过优化器来优化SQL，生成执行计划 选择对应的存储引擎来执行计划，获取数据 向客户端返回查询结果  那么我们就来分别看看这几步都做了哪些事情。
建立连接 客户端与服务端的连接本质上是进程间的通信，进程之间的通信方式有：管道、命名管道、命名字、TCP/IP套接字、UNIX域套接字。我们只讨论最常见的TCP/IP套接字。
mysql -h 127.0.0.1 -u root -p 连接时会查询mysql.user表进行权限校验。
 MySQL的通信协议是半双工的——在任意时刻，要么客户端向服务端发送数据，要么服务端向客户端发送数据。
 查询缓存 如果操作为查询，并且MySQL服务器开启了查询缓存，那么MySQL服务器会对sql进行缓存命中。
这个缓存是由大小写敏感的哈希查找实现的，对sql的任何改动都会导致不能命中缓存。
解析sql 在这一步会校验sql是否符合语法，并将sql解析为token。
查询优化 MySQL使用基于成本的优化器。成本分为IO成本和CPU成本，MySQL会定义每种操作对应的代价。大致流程为：
 根据搜索条件，找出所有可能使用的索引 计算全表扫描的代价 计算使用不同索引执行查询的代价 对比各种方案，选择成本最低的那个  执行语句 只讨论增删改查。
读取记录的过程 缓存都做了什么 InnoDB是以页为单位进行磁盘IO的，如果每次读取都要从磁盘读取，那么性能会很差。因此引入了缓存池——BufferPool，而从磁盘中加载到缓冲池中的页我们称为缓冲页。
每次读取数据页时，都从一个哈希表（key为表空间号&#43;页号，value为控制块）中定位到缓冲页对应的控制块，如果不存在，则从磁盘进行读取，如果存在，则直接读取缓存。
每次从磁盘读取数据页时，都会在Buffer Pool中的free链表中获取空闲页，并填充缓冲页对应的控制块（我们需要这个结构来快速定位到目标缓冲页）。
InnoDB还引入了LRU链表来淘汰最近最少使用的缓冲页（参考InnoDB中的LRU链表）。
在聚簇索引中定位一条记录 通过索引页定位数据页  在索引页中，通过二分法定位记录所在的槽，这个槽对应着索引所在的索引记录组。（索引记录被分成多组，每组的最小值存入Page Directory，称为槽slot） 在索引记录组中通过next_record字段来遍历整个组，找到记录所在的索引页数据（主键&#43;页号） 通过页号找到下一层树的目标索引页 重复上述3个步骤，直到找到最后一层树——即数据页  在数据页中定位目标记录  在数据页中找到Page Directory，通过二分法定位目标记录所在的槽（记录被分成多组，每组的最大值（思考为什么是最大值而不是最小值）存入Page Directory，称为槽slot） 通过Page Directory找到上一个槽，其对应的记录为该组的最大值，然后通过next_record来找到目的槽中的最小值，接着通过next_record来遍历整个目的组找到目标记录。  在二级索引中定位一条记录 定位方式同聚簇索引相同，不同之处在于二级索引中的数据页存储的是主键而不是完整的记录，因此需要通过主键进行回表查询。
锁和事务 事务中不加锁的读 在事务中，如果读操作没有加锁，那么会生成一个ReadView来保证每次读到事务开始前已提交的数据（可重复读的隔离级别下每个事务中的多次读取复用同一个ReadView，读已提交的隔离界别下每次读取都会生成一个新的ReadView）">
    <meta name="keywords" content="">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="查询、插入、删除、更新一条MySQL记录都经历了什么"/>
<meta name="twitter:description" content="一直对MySQL这个黑盒子是如何运行的不甚清楚，因此在这里总结下。
先来了解下MySQL体系架构。
MySQL体系架构 图片来自: https://segmentfault.com/a/1190000039693313
以上图为对照，MySQL的查询会经历大致以下过程：
 客户端与服务端建立连接 查询缓存 将请求的SQL进行解析，并进行语法校验 通过优化器来优化SQL，生成执行计划 选择对应的存储引擎来执行计划，获取数据 向客户端返回查询结果  那么我们就来分别看看这几步都做了哪些事情。
建立连接 客户端与服务端的连接本质上是进程间的通信，进程之间的通信方式有：管道、命名管道、命名字、TCP/IP套接字、UNIX域套接字。我们只讨论最常见的TCP/IP套接字。
mysql -h 127.0.0.1 -u root -p 连接时会查询mysql.user表进行权限校验。
 MySQL的通信协议是半双工的——在任意时刻，要么客户端向服务端发送数据，要么服务端向客户端发送数据。
 查询缓存 如果操作为查询，并且MySQL服务器开启了查询缓存，那么MySQL服务器会对sql进行缓存命中。
这个缓存是由大小写敏感的哈希查找实现的，对sql的任何改动都会导致不能命中缓存。
解析sql 在这一步会校验sql是否符合语法，并将sql解析为token。
查询优化 MySQL使用基于成本的优化器。成本分为IO成本和CPU成本，MySQL会定义每种操作对应的代价。大致流程为：
 根据搜索条件，找出所有可能使用的索引 计算全表扫描的代价 计算使用不同索引执行查询的代价 对比各种方案，选择成本最低的那个  执行语句 只讨论增删改查。
读取记录的过程 缓存都做了什么 InnoDB是以页为单位进行磁盘IO的，如果每次读取都要从磁盘读取，那么性能会很差。因此引入了缓存池——BufferPool，而从磁盘中加载到缓冲池中的页我们称为缓冲页。
每次读取数据页时，都从一个哈希表（key为表空间号&#43;页号，value为控制块）中定位到缓冲页对应的控制块，如果不存在，则从磁盘进行读取，如果存在，则直接读取缓存。
每次从磁盘读取数据页时，都会在Buffer Pool中的free链表中获取空闲页，并填充缓冲页对应的控制块（我们需要这个结构来快速定位到目标缓冲页）。
InnoDB还引入了LRU链表来淘汰最近最少使用的缓冲页（参考InnoDB中的LRU链表）。
在聚簇索引中定位一条记录 通过索引页定位数据页  在索引页中，通过二分法定位记录所在的槽，这个槽对应着索引所在的索引记录组。（索引记录被分成多组，每组的最小值存入Page Directory，称为槽slot） 在索引记录组中通过next_record字段来遍历整个组，找到记录所在的索引页数据（主键&#43;页号） 通过页号找到下一层树的目标索引页 重复上述3个步骤，直到找到最后一层树——即数据页  在数据页中定位目标记录  在数据页中找到Page Directory，通过二分法定位目标记录所在的槽（记录被分成多组，每组的最大值（思考为什么是最大值而不是最小值）存入Page Directory，称为槽slot） 通过Page Directory找到上一个槽，其对应的记录为该组的最大值，然后通过next_record来找到目的槽中的最小值，接着通过next_record来遍历整个目的组找到目标记录。  在二级索引中定位一条记录 定位方式同聚簇索引相同，不同之处在于二级索引中的数据页存储的是主键而不是完整的记录，因此需要通过主键进行回表查询。
锁和事务 事务中不加锁的读 在事务中，如果读操作没有加锁，那么会生成一个ReadView来保证每次读到事务开始前已提交的数据（可重复读的隔离级别下每个事务中的多次读取复用同一个ReadView，读已提交的隔离界别下每次读取都会生成一个新的ReadView）"/>

    <meta property="og:title" content="查询、插入、删除、更新一条MySQL记录都经历了什么" />
<meta property="og:description" content="一直对MySQL这个黑盒子是如何运行的不甚清楚，因此在这里总结下。
先来了解下MySQL体系架构。
MySQL体系架构 图片来自: https://segmentfault.com/a/1190000039693313
以上图为对照，MySQL的查询会经历大致以下过程：
 客户端与服务端建立连接 查询缓存 将请求的SQL进行解析，并进行语法校验 通过优化器来优化SQL，生成执行计划 选择对应的存储引擎来执行计划，获取数据 向客户端返回查询结果  那么我们就来分别看看这几步都做了哪些事情。
建立连接 客户端与服务端的连接本质上是进程间的通信，进程之间的通信方式有：管道、命名管道、命名字、TCP/IP套接字、UNIX域套接字。我们只讨论最常见的TCP/IP套接字。
mysql -h 127.0.0.1 -u root -p 连接时会查询mysql.user表进行权限校验。
 MySQL的通信协议是半双工的——在任意时刻，要么客户端向服务端发送数据，要么服务端向客户端发送数据。
 查询缓存 如果操作为查询，并且MySQL服务器开启了查询缓存，那么MySQL服务器会对sql进行缓存命中。
这个缓存是由大小写敏感的哈希查找实现的，对sql的任何改动都会导致不能命中缓存。
解析sql 在这一步会校验sql是否符合语法，并将sql解析为token。
查询优化 MySQL使用基于成本的优化器。成本分为IO成本和CPU成本，MySQL会定义每种操作对应的代价。大致流程为：
 根据搜索条件，找出所有可能使用的索引 计算全表扫描的代价 计算使用不同索引执行查询的代价 对比各种方案，选择成本最低的那个  执行语句 只讨论增删改查。
读取记录的过程 缓存都做了什么 InnoDB是以页为单位进行磁盘IO的，如果每次读取都要从磁盘读取，那么性能会很差。因此引入了缓存池——BufferPool，而从磁盘中加载到缓冲池中的页我们称为缓冲页。
每次读取数据页时，都从一个哈希表（key为表空间号&#43;页号，value为控制块）中定位到缓冲页对应的控制块，如果不存在，则从磁盘进行读取，如果存在，则直接读取缓存。
每次从磁盘读取数据页时，都会在Buffer Pool中的free链表中获取空闲页，并填充缓冲页对应的控制块（我们需要这个结构来快速定位到目标缓冲页）。
InnoDB还引入了LRU链表来淘汰最近最少使用的缓冲页（参考InnoDB中的LRU链表）。
在聚簇索引中定位一条记录 通过索引页定位数据页  在索引页中，通过二分法定位记录所在的槽，这个槽对应着索引所在的索引记录组。（索引记录被分成多组，每组的最小值存入Page Directory，称为槽slot） 在索引记录组中通过next_record字段来遍历整个组，找到记录所在的索引页数据（主键&#43;页号） 通过页号找到下一层树的目标索引页 重复上述3个步骤，直到找到最后一层树——即数据页  在数据页中定位目标记录  在数据页中找到Page Directory，通过二分法定位目标记录所在的槽（记录被分成多组，每组的最大值（思考为什么是最大值而不是最小值）存入Page Directory，称为槽slot） 通过Page Directory找到上一个槽，其对应的记录为该组的最大值，然后通过next_record来找到目的槽中的最小值，接着通过next_record来遍历整个目的组找到目标记录。  在二级索引中定位一条记录 定位方式同聚簇索引相同，不同之处在于二级索引中的数据页存储的是主键而不是完整的记录，因此需要通过主键进行回表查询。
锁和事务 事务中不加锁的读 在事务中，如果读操作没有加锁，那么会生成一个ReadView来保证每次读到事务开始前已提交的数据（可重复读的隔离级别下每个事务中的多次读取复用同一个ReadView，读已提交的隔离界别下每次读取都会生成一个新的ReadView）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://stong1994.github.io/internet/MySQL/curd/" /><meta property="article:section" content="internet" />
<meta property="article:published_time" content="2021-10-06T17:05:00+08:00" />
<meta property="article:modified_time" content="2021-10-06T17:05:00+08:00" />



    <title>
  查询、插入、删除、更新一条MySQL记录都经历了什么 · cristo
</title>

    
      <link rel="canonical" href="https://stong1994.github.io/internet/MySQL/curd/">
    

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700&display=swap" rel="stylesheet">
    <link rel="preload" href="/fonts/forkawesome-webfont.woff2?v=1.1.7" as="font" type="font/woff2" crossorigin>

    
      
      
      <link rel="stylesheet" href="/css/coder.min.6d489c9de70b01718344ed2ac642db21c4bb3c62941cb95963c2b67c66c07fdc.css" integrity="sha256-bUicnecLAXGDRO0qxkLbIcS7PGKUHLlZY8K2fGbAf9w=" crossorigin="anonymous" media="screen" />
    

    

    
      
        
        
        <link rel="stylesheet" href="/css/coder-dark.min.126ad3988d46bdae6217a11105b53c9662bca05f39d42d3c0fb366919d334620.css" integrity="sha256-EmrTmI1Gva5iF6ERBbU8lmK8oF851C08D7NmkZ0zRiA=" crossorigin="anonymous" media="screen" />
      
    

    

    

    <link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

    <link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

    
      <script defer src="https://twemoji.maxcdn.com/v/13.0.1/twemoji.min.js"
        integrity="sha384-5f4X0lBluNY/Ib4VhGx0Pf6iDCF99VGXJIyYy7dDLY5QlEd7Ap0hICSSZA1XYbc4" crossorigin="anonymous"></script>
    

    <meta name="generator" content="Hugo 0.89.4" />
  </head>

  
  
    
  
  <body class="colorscheme-auto"
        onload=" twemoji.parse(document.body); "
  >
    
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      cristo
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/internet/">互联网</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/book/">读书</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/life/">生活</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/about/">关于</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


      <div class="content">
        
    <div id="toc" class="well col-md-4 col-sm-6">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#读取记录的过程">读取记录的过程</a>
      <ul>
        <li><a href="#缓存都做了什么">缓存都做了什么</a></li>
        <li><a href="#在聚簇索引中定位一条记录">在聚簇索引中定位一条记录</a></li>
        <li><a href="#在二级索引中定位一条记录">在二级索引中定位一条记录</a></li>
        <li><a href="#锁和事务">锁和事务</a></li>
      </ul>
    </li>
    <li><a href="#插入记录的过程">插入记录的过程</a>
      <ul>
        <li><a href="#row_id的赋值步骤">row_id的赋值步骤</a></li>
        <li><a href="#自增列的数据生成">自增列的数据生成</a></li>
        <li><a href="#确定插入位置">确定插入位置</a></li>
        <li><a href="#申请空间">申请空间</a></li>
        <li><a href="#申请页">申请页</a></li>
        <li><a href="#锁与事务">锁与事务</a></li>
        <li><a href="#二级索引">二级索引</a></li>
      </ul>
    </li>
    <li><a href="#删除记录的过程">删除记录的过程</a>
      <ul>
        <li><a href="#找到记录位置">找到记录位置</a></li>
        <li><a href="#删除记录">删除记录</a></li>
      </ul>
    </li>
    <li><a href="#更新记录的过程">更新记录的过程</a>
      <ul>
        <li><a href="#找到记录位置-1">找到记录位置</a></li>
        <li><a href="#更细记录">更细记录</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
  <section class="container page">
  <article>
    <header>
      <h1>查询、插入、删除、更新一条MySQL记录都经历了什么</h1>
    </header>

    <p>一直对MySQL这个黑盒子是如何运行的不甚清楚，因此在这里总结下。</p>
<p>先来了解下MySQL体系架构。</p>
<h1 id="mysql体系架构">MySQL体系架构</h1>
<p><img src="https://raw.githubusercontent.com/stong1994/images/master/picgo/20211006171205.jfif" alt=""></p>
<p><em>图片来自: <a href="https://segmentfault.com/a/1190000039693313">https://segmentfault.com/a/1190000039693313</a></em></p>
<p>以上图为对照，MySQL的查询会经历大致以下过程：</p>
<ol>
<li>客户端与服务端建立连接</li>
<li>查询缓存</li>
<li>将请求的SQL进行解析，并进行语法校验</li>
<li>通过优化器来优化SQL，生成执行计划</li>
<li>选择对应的存储引擎来执行计划，获取数据</li>
<li>向客户端返回查询结果</li>
</ol>
<p>那么我们就来分别看看这几步都做了哪些事情。</p>
<h1 id="建立连接">建立连接</h1>
<p>客户端与服务端的连接本质上是进程间的通信，进程之间的通信方式有：管道、命名管道、命名字、TCP/IP套接字、UNIX域套接字。我们只讨论最常见的TCP/IP套接字。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">mysql -h 127.0.0.1 -u root -p
</code></pre></div><p>连接时会查询<code>mysql.user</code>表进行权限校验。</p>
<blockquote>
<p>MySQL的通信协议是半双工的——在任意时刻，要么客户端向服务端发送数据，要么服务端向客户端发送数据。</p>
</blockquote>
<h1 id="查询缓存">查询缓存</h1>
<p>如果操作为查询，并且MySQL服务器开启了查询缓存，那么MySQL服务器会对sql进行缓存命中。</p>
<p>这个缓存是由大小写敏感的哈希查找实现的，对sql的任何改动都会导致不能命中缓存。</p>
<h1 id="解析sql">解析sql</h1>
<p>在这一步会校验sql是否符合语法，并将sql解析为token。</p>
<h1 id="查询优化">查询优化</h1>
<p>MySQL使用基于成本的优化器。成本分为IO成本和CPU成本，MySQL会定义每种操作对应的代价。大致流程为：</p>
<ol>
<li>根据搜索条件，找出所有可能使用的索引</li>
<li>计算全表扫描的代价</li>
<li>计算使用不同索引执行查询的代价</li>
<li>对比各种方案，选择成本最低的那个</li>
</ol>
<h1 id="执行语句">执行语句</h1>
<p>只讨论增删改查。</p>
<h2 id="读取记录的过程">读取记录的过程</h2>
<h3 id="缓存都做了什么">缓存都做了什么</h3>
<p>InnoDB是以页为单位进行磁盘IO的，如果每次读取都要从磁盘读取，那么性能会很差。因此引入了缓存池——<code>BufferPool</code>，而从磁盘中加载到缓冲池中的页我们称为<strong>缓冲页</strong>。</p>
<p>每次读取数据页时，都从一个<strong>哈希表</strong>（key为表空间号+页号，value为控制块）中<strong>定位</strong>到<strong>缓冲页对应的控制块</strong>，如果不存在，则从磁盘进行读取，如果存在，则直接读取缓存。</p>
<p>每次从磁盘读取数据页时，都会在<code>Buffer Pool</code>中的<strong>free链表</strong>中获取空闲页，并<strong>填充缓冲页对应的控制块</strong>（我们需要这个结构来快速定位到目标缓冲页）。</p>
<p>InnoDB还引入了LRU链表来淘汰最近最少使用的缓冲页（参考<a href="">InnoDB中的LRU链表</a>）。</p>
<h3 id="在聚簇索引中定位一条记录">在聚簇索引中定位一条记录</h3>
<h4 id="通过索引页定位数据页">通过索引页定位数据页</h4>
<ol>
<li>在<strong>索引页</strong>中，通过<strong>二分法</strong>定位记录所在的<strong>槽</strong>，这个槽对应着索引所在的<strong>索引记录组</strong>。（索引记录被分成多组，每组的最小值存入Page Directory，称为槽slot）</li>
<li>在<strong>索引记录组</strong>中通过<code>next_record</code>字段来<strong>遍历</strong>整个组，找到记录所在的索引页数据（主键+页号）</li>
<li>通过<strong>页号</strong>找到<strong>下一层树</strong>的<strong>目标索引页</strong></li>
<li>重复上述3个步骤，直到找到最后一层树——即数据页</li>
</ol>
<h4 id="在数据页中定位目标记录">在数据页中定位目标记录</h4>
<ol>
<li>在<strong>数据页</strong>中找到<code>Page Directory</code>，通过<strong>二分法</strong>定位目标记录所在的<strong>槽</strong>（记录被分成多组，每组的最大值（<em>思考为什么是最大值而不是最小值</em>）存入Page Directory，称为槽slot）</li>
<li>通过<code>Page Directory</code>找到<strong>上一个槽</strong>，其对应的记录为该组的最大值，然后通过<code>next_record</code>来找到<strong>目的槽中的最小值</strong>，接着通过<code>next_record</code>来<strong>遍历整个目的组</strong>找到目标记录。</li>
</ol>
<h3 id="在二级索引中定位一条记录">在二级索引中定位一条记录</h3>
<p>定位方式同聚簇索引相同，不同之处在于<strong>二级索引中的数据页存储的是主键而不是完整的记录</strong>，因此需要通过主键进行<strong>回表</strong>查询。</p>
<h3 id="锁和事务">锁和事务</h3>
<h4 id="事务中不加锁的读">事务中不加锁的读</h4>
<p>在事务中，如果读操作没有加锁，那么会生成一个ReadView来保证每次读到事务开始前已提交的数据（可重复读的隔离级别下每个事务中的多次读取复用同一个ReadView，读已提交的隔离界别下每次读取都会生成一个新的ReadView）</p>
<h4 id="事务中加锁的读">事务中加锁的读</h4>
<p>对读加锁有两种方式：</p>
<ul>
<li><code>SELECT .. LOCK IN SHARE MODE; </code>: 这是一个S锁</li>
<li><code>SELECT ... FOR UPDATE;</code>: 这是一个X锁</li>
</ul>
<p>通过对读操作加锁，从而阻止其他事务对目的记录进行修改（在有些场景，我们不允许其他事务对我们正在读取的记录进行修改）。</p>
<p>进行加锁操作也能使在可重复读级别下完全避免幻读（参考<a href="">MVCC产生幻读的特殊情况</a>）。</p>
<h2 id="插入记录的过程">插入记录的过程</h2>
<p>如果创建表时没有定义主键且没有建立NOT NULL的唯一的索引键，那么InnoDB会创建一个隐式列row_id作为主键。因此需要对每一条记录生成一个row_id。</p>
<h3 id="row_id的赋值步骤">row_id的赋值步骤</h3>
<ol>
<li>服务器在内存中维护一个全局变量，每当向包含row_id的表中插入一条记录时，获取这个变量作为row_id的值，并把这个全局变量自增1</li>
<li>每当全局变量的值变为256的倍数时，就会将该变量写入系统表空间中</li>
<li>当系统启动时，将系统表空间中的该变量加上256加载到内存中（加256是为了确保内存中的值一定比记录中已存在的row_id值大）</li>
</ol>
<h3 id="自增列的数据生成">自增列的数据生成</h3>
<p>自增数据的生成需要用到锁，有两种情况：</p>
<ol>
<li>自增锁：这是一个表级别的锁，生成数据时，需要先获取锁，语句执行后再释放</li>
<li>轻量级锁：生成数据时进行获取锁，生成数据完成后即释放，不用等待语句执行</li>
</ol>
<h3 id="确定插入位置">确定插入位置</h3>
<ol>
<li>
<p>通过聚簇索引的目录项找到数据页</p>
</li>
<li>
<p>再通过数据页的页目录找到数据应存储的槽</p>
<ol>
<li>如果槽对应的记录组的记录数量小于8个，那么直接插入到这个记录组中</li>
<li>如果槽对应的记录组的记录数量为8个，那么就需要将这个组分成两个组，存储主键较小的组中存放5条数据，同时在页目录中新增一个槽</li>
</ol>
</li>
</ol>
<h3 id="申请空间">申请空间</h3>
<p>确定插入位置后，需要申请空间进行存储记录。</p>
<ol>
<li>
<p>如果数据页中有足够的空闲空间，那么直接使用剩余的空间即可。</p>
</li>
<li>
<p>如果数据页中没有足够的空闲空间，且新记录主键的值大于已有的记录，那么就申请一个新的页来存储。</p>
</li>
<li>
<p>如果数据页中没有足够的空闲空间，且新记录主键不是最大值，那就去垃圾链表中找到第一个记录，看所占空间是否足够存储新记录</p>
<ol>
<li>
<p>如果足够，那么就将这个部分空间给到新记录，将多余的空间增加到PAGE HEADER中的可重用空间大小属性（PAGE_GARBAGE）。</p>
</li>
<li>
<p>如果垃圾链表中首个记录的空间不足以存储新记录，那么就查看整个页的可重用空间加上空闲空间是否足够存储新记录。</p>
<ol>
<li>如果足够，那么就重新组织页面——将用户记录写入到一个临时页，然后再将临时页的数据写会到数据页</li>
<li>如果不够，那么就申请一个新的页，并进行页分裂</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="申请页">申请页</h3>
<ol>
<li>
<p>数据页所在的段如果已包含32个碎片区，那么直接申请一个完整的区，并在区中申请一个页空间。</p>
</li>
<li>
<p>数据页所在的段如果未包含32个碎片区，那么从碎片区中申请一个空闲页。</p>
<ol>
<li>如果表空间中存在有空闲页的碎片区，那么直接在这个碎片区申请一个空闲页</li>
<li>如果表空间中的碎片区不包含空闲页，那么在表空间中先申请一个碎片区，然后再申请一个空闲页</li>
</ol>
</li>
</ol>
<h3 id="锁与事务">锁与事务</h3>
<h4 id="插入意向锁">插入意向锁</h4>
<p>如果新记录插入的<strong>间隙被其他事务加了gap锁</strong>，那么插入操作会<strong>阻塞</strong>，并且当前事务在间隙上增加一个<strong>插入意向锁</strong>。插入意向锁能够加速并发插入——<strong>插入意向锁之间并不互斥，对一个间隙内的多条记录，可以同时插入</strong>。</p>
<p>插入意向锁example：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#f00">终端</span><span style="color:#ff0;font-weight:bold">1</span><span style="color:#f00">：</span>mysql&gt; begin;<span style="color:#fff;font-weight:bold">SELECT</span> * <span style="color:#fff;font-weight:bold">FROM</span> <span style="color:#fff;font-weight:bold">user</span> <span style="color:#fff;font-weight:bold">where</span> id &lt;= <span style="color:#ff0;font-weight:bold">8</span> <span style="color:#fff;font-weight:bold">for</span> <span style="color:#fff;font-weight:bold">update</span>;<span style="color:#007f7f">#对id小于8的记录加gap锁
</span><span style="color:#007f7f"></span><span style="color:#f00">终端</span><span style="color:#ff0;font-weight:bold">2</span>: mysql&gt; begin;<span style="color:#fff;font-weight:bold">insert</span> <span style="color:#fff;font-weight:bold">into</span> <span style="color:#fff;font-weight:bold">user</span>(id, name) <span style="color:#fff;font-weight:bold">values</span>(<span style="color:#ff0;font-weight:bold">6</span>, <span style="color:#0ff;font-weight:bold">&#39;6&#39;</span>); <span style="color:#007f7f"># 此时生成插入意向锁，并进入等待
</span><span style="color:#007f7f"></span><span style="color:#f00">终端</span><span style="color:#ff0;font-weight:bold">3</span>: mysql&gt; begin;<span style="color:#fff;font-weight:bold">insert</span> <span style="color:#fff;font-weight:bold">into</span> <span style="color:#fff;font-weight:bold">user</span>(id, name) <span style="color:#fff;font-weight:bold">values</span>(<span style="color:#ff0;font-weight:bold">7</span>, <span style="color:#0ff;font-weight:bold">&#39;7&#39;</span>); <span style="color:#007f7f"># 此时生成插入意向锁，并进入等待
</span><span style="color:#007f7f"></span><span style="color:#f00">终端</span><span style="color:#ff0;font-weight:bold">1</span>: commit; <span style="color:#007f7f"># 此时终端2和3同时获取到锁，并执行语句。
</span></code></pre></div><h4 id="隐式锁">隐式锁</h4>
<p>新插入的数据受<strong>隐式锁</strong>保护：当事务在读取一条新插入的记录时，会根据这条记录的事务id来判断是否能够读取。如果<strong>事务id大于Read View中的最大事务id，那么就不能读取</strong>，如果<strong>事务id是Read View中的活跃事务id，那么不能立即读取，需要帮助这条记录创建一个X锁结构，然后再为自己创建一个S锁结构，标识为等待</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#f00">终端</span><span style="color:#ff0;font-weight:bold">1</span>: mysql&gt; begin;<span style="color:#fff;font-weight:bold">insert</span> <span style="color:#fff;font-weight:bold">into</span> <span style="color:#fff;font-weight:bold">user</span>(id, name) <span style="color:#fff;font-weight:bold">values</span>(<span style="color:#ff0;font-weight:bold">6</span>, <span style="color:#0ff;font-weight:bold">&#39;6&#39;</span>); <span style="color:#007f7f"># 此时新记录未提交
</span><span style="color:#007f7f"></span><span style="color:#f00">终端</span><span style="color:#ff0;font-weight:bold">2</span>: mysql&gt; begin;<span style="color:#fff;font-weight:bold">select</span> * <span style="color:#fff;font-weight:bold">from</span> <span style="color:#fff;font-weight:bold">user</span> <span style="color:#fff;font-weight:bold">where</span> id = <span style="color:#ff0;font-weight:bold">6</span> <span style="color:#fff;font-weight:bold">LOCK</span> <span style="color:#fff;font-weight:bold">IN</span> SHARE MODE; <span style="color:#007f7f"># 此时为id=6生成X锁，未自身生成S锁，并等待(如果没有加S锁，则不会等待)
</span><span style="color:#007f7f"></span><span style="color:#f00">终端</span><span style="color:#ff0;font-weight:bold">3</span>: mysql&gt; begin;<span style="color:#fff;font-weight:bold">update</span> <span style="color:#fff;font-weight:bold">user</span> <span style="color:#fff;font-weight:bold">set</span> name = <span style="color:#0ff;font-weight:bold">&#39;7&#39;</span> <span style="color:#fff;font-weight:bold">where</span> id = <span style="color:#ff0;font-weight:bold">6</span>; <span style="color:#007f7f"># 此时未获得锁，等待
</span><span style="color:#007f7f"></span><span style="color:#f00">终端</span><span style="color:#ff0;font-weight:bold">1</span>: commit; <span style="color:#007f7f"># 此时终端2获取到锁，并执行查询语句，能够查询到id=6的记录。
</span><span style="color:#007f7f"></span><span style="color:#f00">终端</span><span style="color:#ff0;font-weight:bold">2</span>: commit; <span style="color:#007f7f"># 此时终端3获取到锁，并执行update语句，能够正常更新。
</span></code></pre></div><h4 id="undo-log">undo log</h4>
<p>向undo log中加入一条记录，主要记录事务id、主键信息等，用于执行回滚。</p>
<h3 id="二级索引">二级索引</h3>
<p>二级索引记录的插入和聚簇索引相似，但二级索引记录中没有事务id，每次对页进行更新时，需要把Page Header中的最大事务ID进行更新。</p>
<h2 id="删除记录的过程">删除记录的过程</h2>
<h3 id="找到记录位置">找到记录位置</h3>
<p>其方式和“插入数据的过程”中的“找到插入位置”相同。</p>
<h3 id="删除记录">删除记录</h3>
<p>找到记录后，其删除步骤分两部分：</p>
<ol>
<li><strong>标记为删除</strong>：每行记录都有一个删除标志位，用于标识记录是否已删除（为了其他事务还能读取到，因此不能立即删除）。并生成对应的undo log</li>
<li>将记录从正常记录链中移除，并<strong>加入到垃圾链表</strong>中，同时更新页的可重用空间、页目录等信息（purge阶段执行）</li>
</ol>
<p>对于二级索引，根据聚簇索引对二级索引进行更新即可。</p>
<h2 id="更新记录的过程">更新记录的过程</h2>
<h3 id="找到记录位置-1">找到记录位置</h3>
<p>其方式和“插入数据的过程”中的“找到插入位置”相同。</p>
<h3 id="更细记录">更细记录</h3>
<h4 id="更新主键">更新主键</h4>
<p>如果需要更新主键，那么其操作为删除操作+插入操作</p>
<ol>
<li>将旧记录标记为删除（不将其立即加入垃圾链表，因为别的事务还可能用到，后续在purge阶段处理）</li>
<li>对新记录执行插入操作</li>
</ol>
<p>同时生成两个undo log。</p>
<h4 id="不更新主键">不更新主键</h4>
<ol>
<li>如果新旧记录的各列长度均相同，那么直接进行原地更新，并生成undo log</li>
<li>如果至少有一列的新旧数据长度不同，那么
<ol>
<li>将记录立即加入到垃圾链表中</li>
<li>如果旧记录长度大于新记录，那么新记录可以复用旧记录的空间，否则申请新空间</li>
</ol>
</li>
</ol>

  </article>
</section>

  

      </div>

      
  <footer class="footer">
    <section class="container">
      
        <p>夭寿不贰，修身以俟</p>
      
      
        ©
        
          2021 -
        
        2022
        
      
      
         · 
         <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
      
      
    </section>
  </footer>


    </main>

    
      
        
        <script src="/js/dark-mode.min.aee9c8a464eb7b3534c7110f7c5e169e7039e2fd92710e0626d451d6725af137.js"></script>
      
    

    

    

    

    

    

    

    
  </body>

</html>
