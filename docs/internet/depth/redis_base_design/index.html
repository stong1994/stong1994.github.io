<!DOCTYPE html>
<html lang="zh">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Language" content="zh">
    

    
    <meta name="description" content="很久之前就看过redis的基本设计与实现，但是每次都会忘掉。
前几天又看了一遍，但是最近回顾的时候又忘了。。。
俗话说好记性不如烂笔头，因此写在这里来加深记忆。
文中会将数据类型的实现与go中的实现进行对比，如有理解错误的地方，望指出
五个基本数据类型 string  go中的string：在go中，string就是一组字节，且是不可变的。可以视作字节数组。
 redis中的字符串对象的编码可以是int、raw或embstr。
如果保存的对象是整数且可以用long类型来表示，那么就保存为整数，编码为int。
如果保存的对象是字符串且长度小于等于32字节，那么会使用embstr的编码来保存。
如果保存的对象是字符串且长度大于32字节，那么会使用embstr的编码来保存，且存储在SDS中。
embstr是专门用来保存短字符串的一种优化编码方式，与raw的区别在于对于redisObject和sdshdr（redisObject是redis对象中的一个属性，sdshdr是SDS的实现），embstr只需一次内存分配，而raw需要两次。
SDS 简单动态字符串（SDS）组成：
 buf: 字节数组 len: 字符串长度（即buf数组中已使用的字节数量） free: buf数组中未使用的字节数量  SDS遵循C字符串以空字符结尾的惯例，保存空字符串的1字节空间不计算在SDS的属性中。
空间预分配策略：修改之后的SDS长度小于1M，那么程序会分配同样大小的预留空间，即len=free；如果修改之后的SDS长度大于1M，那么程序会分配1M的预留空间。
空间惰性释放策略：SDS中的字符串长度减小时，并不直接释放空间，而是增大free，可供未来使用，避免频繁释放/分配空间。
list  go中的slice
构成：由三个属性构成：长度、容量、底层数组。
扩容策略：当容量小于1024时，每次扩容为原来容量的一倍；否则扩容1/4
缩容策略：无
 当list中元素的字符串长度都小于64字节且元素数量小于512时，使用压缩列表实现，否则使用双端链表实现。
双端链表 双端链表有如下几个属性：
 表头节点 表尾结点 节点长度 节点复制函数 节点释放函数 节点值对比函数  节点有如下属性：
  前置节点地址
  后置节点地址
  节点值
  压缩列表 压缩列表包含的属性：
 整个压缩列表占用的字节数 计算列表尾结点距离压缩列表的起始地址有多少字节 记录压缩列表包含的节点的数量（当总数大于65535时，这个字段失效，需要遍历整个压缩列表才能计算出来） 列表节点数组（每个节点可以保存为一个字节数组或者整数）  列表节点包含的属性：
 上一个节点的长度 编码类型与长度 节点内容  压缩列表的优点就是节省内存，缺点就是增加、删除、更新可能会造成“连锁更新”，因此只有在包含少量元素时才使用。">
    <meta name="keywords" content="">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="简述redis的基本实现"/>
<meta name="twitter:description" content="很久之前就看过redis的基本设计与实现，但是每次都会忘掉。
前几天又看了一遍，但是最近回顾的时候又忘了。。。
俗话说好记性不如烂笔头，因此写在这里来加深记忆。
文中会将数据类型的实现与go中的实现进行对比，如有理解错误的地方，望指出
五个基本数据类型 string  go中的string：在go中，string就是一组字节，且是不可变的。可以视作字节数组。
 redis中的字符串对象的编码可以是int、raw或embstr。
如果保存的对象是整数且可以用long类型来表示，那么就保存为整数，编码为int。
如果保存的对象是字符串且长度小于等于32字节，那么会使用embstr的编码来保存。
如果保存的对象是字符串且长度大于32字节，那么会使用embstr的编码来保存，且存储在SDS中。
embstr是专门用来保存短字符串的一种优化编码方式，与raw的区别在于对于redisObject和sdshdr（redisObject是redis对象中的一个属性，sdshdr是SDS的实现），embstr只需一次内存分配，而raw需要两次。
SDS 简单动态字符串（SDS）组成：
 buf: 字节数组 len: 字符串长度（即buf数组中已使用的字节数量） free: buf数组中未使用的字节数量  SDS遵循C字符串以空字符结尾的惯例，保存空字符串的1字节空间不计算在SDS的属性中。
空间预分配策略：修改之后的SDS长度小于1M，那么程序会分配同样大小的预留空间，即len=free；如果修改之后的SDS长度大于1M，那么程序会分配1M的预留空间。
空间惰性释放策略：SDS中的字符串长度减小时，并不直接释放空间，而是增大free，可供未来使用，避免频繁释放/分配空间。
list  go中的slice
构成：由三个属性构成：长度、容量、底层数组。
扩容策略：当容量小于1024时，每次扩容为原来容量的一倍；否则扩容1/4
缩容策略：无
 当list中元素的字符串长度都小于64字节且元素数量小于512时，使用压缩列表实现，否则使用双端链表实现。
双端链表 双端链表有如下几个属性：
 表头节点 表尾结点 节点长度 节点复制函数 节点释放函数 节点值对比函数  节点有如下属性：
  前置节点地址
  后置节点地址
  节点值
  压缩列表 压缩列表包含的属性：
 整个压缩列表占用的字节数 计算列表尾结点距离压缩列表的起始地址有多少字节 记录压缩列表包含的节点的数量（当总数大于65535时，这个字段失效，需要遍历整个压缩列表才能计算出来） 列表节点数组（每个节点可以保存为一个字节数组或者整数）  列表节点包含的属性：
 上一个节点的长度 编码类型与长度 节点内容  压缩列表的优点就是节省内存，缺点就是增加、删除、更新可能会造成“连锁更新”，因此只有在包含少量元素时才使用。"/>

    <meta property="og:title" content="简述redis的基本实现" />
<meta property="og:description" content="很久之前就看过redis的基本设计与实现，但是每次都会忘掉。
前几天又看了一遍，但是最近回顾的时候又忘了。。。
俗话说好记性不如烂笔头，因此写在这里来加深记忆。
文中会将数据类型的实现与go中的实现进行对比，如有理解错误的地方，望指出
五个基本数据类型 string  go中的string：在go中，string就是一组字节，且是不可变的。可以视作字节数组。
 redis中的字符串对象的编码可以是int、raw或embstr。
如果保存的对象是整数且可以用long类型来表示，那么就保存为整数，编码为int。
如果保存的对象是字符串且长度小于等于32字节，那么会使用embstr的编码来保存。
如果保存的对象是字符串且长度大于32字节，那么会使用embstr的编码来保存，且存储在SDS中。
embstr是专门用来保存短字符串的一种优化编码方式，与raw的区别在于对于redisObject和sdshdr（redisObject是redis对象中的一个属性，sdshdr是SDS的实现），embstr只需一次内存分配，而raw需要两次。
SDS 简单动态字符串（SDS）组成：
 buf: 字节数组 len: 字符串长度（即buf数组中已使用的字节数量） free: buf数组中未使用的字节数量  SDS遵循C字符串以空字符结尾的惯例，保存空字符串的1字节空间不计算在SDS的属性中。
空间预分配策略：修改之后的SDS长度小于1M，那么程序会分配同样大小的预留空间，即len=free；如果修改之后的SDS长度大于1M，那么程序会分配1M的预留空间。
空间惰性释放策略：SDS中的字符串长度减小时，并不直接释放空间，而是增大free，可供未来使用，避免频繁释放/分配空间。
list  go中的slice
构成：由三个属性构成：长度、容量、底层数组。
扩容策略：当容量小于1024时，每次扩容为原来容量的一倍；否则扩容1/4
缩容策略：无
 当list中元素的字符串长度都小于64字节且元素数量小于512时，使用压缩列表实现，否则使用双端链表实现。
双端链表 双端链表有如下几个属性：
 表头节点 表尾结点 节点长度 节点复制函数 节点释放函数 节点值对比函数  节点有如下属性：
  前置节点地址
  后置节点地址
  节点值
  压缩列表 压缩列表包含的属性：
 整个压缩列表占用的字节数 计算列表尾结点距离压缩列表的起始地址有多少字节 记录压缩列表包含的节点的数量（当总数大于65535时，这个字段失效，需要遍历整个压缩列表才能计算出来） 列表节点数组（每个节点可以保存为一个字节数组或者整数）  列表节点包含的属性：
 上一个节点的长度 编码类型与长度 节点内容  压缩列表的优点就是节省内存，缺点就是增加、删除、更新可能会造成“连锁更新”，因此只有在包含少量元素时才使用。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://stong1994.github.io/internet/depth/redis_base_design/" /><meta property="article:section" content="internet" />
<meta property="article:published_time" content="2021-11-22T16:05:00+08:00" />
<meta property="article:modified_time" content="2021-11-22T16:05:00+08:00" />



    <title>
  简述redis的基本实现 · 北人
</title>

    
      <link rel="canonical" href="https://stong1994.github.io/internet/depth/redis_base_design/">
    

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700&display=swap" rel="stylesheet">
    <link rel="preload" href="/fonts/forkawesome-webfont.woff2?v=1.1.7" as="font" type="font/woff2" crossorigin>

    
      
      
      <link rel="stylesheet" href="/css/coder.min.6d489c9de70b01718344ed2ac642db21c4bb3c62941cb95963c2b67c66c07fdc.css" integrity="sha256-bUicnecLAXGDRO0qxkLbIcS7PGKUHLlZY8K2fGbAf9w=" crossorigin="anonymous" media="screen" />
    

    

    
      
        
        
        <link rel="stylesheet" href="/css/coder-dark.min.126ad3988d46bdae6217a11105b53c9662bca05f39d42d3c0fb366919d334620.css" integrity="sha256-EmrTmI1Gva5iF6ERBbU8lmK8oF851C08D7NmkZ0zRiA=" crossorigin="anonymous" media="screen" />
      
    

    

    

    <link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

    <link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

    
      <script defer src="https://twemoji.maxcdn.com/v/13.0.1/twemoji.min.js"
        integrity="sha384-5f4X0lBluNY/Ib4VhGx0Pf6iDCF99VGXJIyYy7dDLY5QlEd7Ap0hICSSZA1XYbc4" crossorigin="anonymous"></script>
    

    <meta name="generator" content="Hugo 0.89.4" />
  </head>

  
  
    
  
  <body class="colorscheme-auto"
        onload=" twemoji.parse(document.body); "
  >
    
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      北人
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/internet/">计算机与互联网</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/book/">读书</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/life/">生活</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/about/">关于</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


      <div class="content">
        
    <div id="toc" class="well col-md-4 col-sm-6">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#五个基本数据类型">五个基本数据类型</a>
      <ul>
        <li><a href="#string">string</a></li>
        <li><a href="#list">list</a></li>
        <li><a href="#hash">hash</a></li>
        <li><a href="#set">set</a></li>
        <li><a href="#sorted-set">sorted set</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
  <section class="container page">
  <article>
    <header>
      <h1>简述redis的基本实现</h1>
    </header>

    <p>很久之前就看过redis的基本设计与实现，但是每次都会忘掉。</p>
<p>前几天又看了一遍，但是最近回顾的时候又忘了。。。</p>
<p>俗话说好记性不如烂笔头，因此写在这里来加深记忆。</p>
<p><em>文中会将数据类型的实现与go中的实现进行对比，如有理解错误的地方，望指出</em></p>
<h2 id="五个基本数据类型">五个基本数据类型</h2>
<h3 id="string">string</h3>
<blockquote>
<p><strong>go中的string</strong>：在go中，string就是一组字节，且是不可变的。可以视作字节数组。</p>
</blockquote>
<p>redis中的字符串对象的编码可以是int、raw或embstr。</p>
<p>如果保存的对象是整数且可以用long类型来表示，那么就保存为整数，编码为int。</p>
<p>如果保存的对象是字符串且长度小于等于32字节，那么会使用embstr的编码来保存。</p>
<p>如果保存的对象是字符串且长度大于32字节，那么会使用embstr的编码来保存，且存储在SDS中。</p>
<p>embstr是专门用来保存短字符串的一种优化编码方式，与raw的区别在于对于redisObject和sdshdr（redisObject是redis对象中的一个属性，sdshdr是SDS的实现），embstr只需一次内存分配，而raw需要两次。</p>
<h4 id="sds">SDS</h4>
<p>简单动态字符串（SDS）组成：</p>
<ul>
<li>buf: 字节数组</li>
<li>len: 字符串长度（即buf数组中已使用的字节数量）</li>
<li>free: buf数组中未使用的字节数量</li>
</ul>
<p>SDS遵循C字符串以空字符结尾的惯例，保存空字符串的1字节空间不计算在SDS的属性中。</p>
<p><strong>空间预分配策略</strong>：修改之后的SDS长度小于1M，那么程序会分配同样大小的预留空间，即len=free；如果修改之后的SDS长度大于1M，那么程序会分配1M的预留空间。</p>
<p><strong>空间惰性释放策略</strong>：SDS中的字符串长度减小时，并不直接释放空间，而是增大free，可供未来使用，避免频繁释放/分配空间。</p>
<h3 id="list">list</h3>
<blockquote>
<p><strong>go中的slice</strong></p>
<p>构成：由三个属性构成：长度、容量、底层数组。</p>
<p>扩容策略：当容量小于1024时，每次扩容为原来容量的一倍；否则扩容1/4</p>
<p>缩容策略：无</p>
</blockquote>
<p>当list中元素的<strong>字符串长度都小于64字节</strong>且<strong>元素数量小于512</strong>时，使用<strong>压缩列表</strong>实现，否则使用<strong>双端链表</strong>实现。</p>
<h4 id="双端链表">双端链表</h4>
<p>双端链表有如下几个属性：</p>
<ul>
<li>表头节点</li>
<li>表尾结点</li>
<li>节点长度</li>
<li>节点复制函数</li>
<li>节点释放函数</li>
<li>节点值对比函数</li>
</ul>
<p>节点有如下属性：</p>
<ul>
<li>
<p>前置节点地址</p>
</li>
<li>
<p>后置节点地址</p>
</li>
<li>
<p>节点值</p>
</li>
</ul>
<h4 id="压缩列表">压缩列表</h4>
<p>压缩列表包含的属性：</p>
<ul>
<li>整个压缩列表占用的字节数</li>
<li>计算列表尾结点距离压缩列表的起始地址有多少字节</li>
<li>记录压缩列表包含的节点的数量（当总数大于65535时，这个字段失效，需要遍历整个压缩列表才能计算出来）</li>
<li>列表节点数组（每个节点可以保存为一个字节数组或者整数）</li>
</ul>
<p>列表节点包含的属性：</p>
<ul>
<li>上一个节点的长度</li>
<li>编码类型与长度</li>
<li>节点内容</li>
</ul>
<p>压缩列表的优点就是节省内存，缺点就是增加、删除、更新可能会造成“连锁更新”，因此只有在包含少量元素时才使用。</p>
<h3 id="hash">hash</h3>
<blockquote>
<p><strong>go中的map</strong>：涉及内容太多，todo</p>
</blockquote>
<p>当hash中的<strong>key和value的长度都小于64字节</strong>，且<strong>键值对的数量小于512个</strong>时，使用<strong>压缩列表</strong>实现，否则使用<strong>字典</strong>实现。</p>
<h4 id="压缩列表-1">压缩列表</h4>
<p>key和value都作为节点存到列表中，且一个键值对的两个节点总是按着。新加的键值对节点置于表尾。</p>
<h4 id="字典">字典</h4>
<p>字典中包含以下几个属性：</p>
<ul>
<li>类型特定函数</li>
<li>私有数据</li>
<li>哈希表数组：数组长度固定为2</li>
<li>rehash索引，为-1时，表示没有进行rehash</li>
</ul>
<p>哈希表包含以下几个属性：</p>
<ul>
<li>size: 哈希表大小</li>
<li>sizemask: 哈希表大小掩码，用于计算索引值。总是等于size-1</li>
<li>used: 已使用的数量</li>
<li>哈希表数组，每个数组都是一个节点</li>
</ul>
<p>哈希节点包含的属性：</p>
<ul>
<li>key</li>
<li>value</li>
<li>下个节点的地址（用于组成解决哈希冲突的链表）</li>
</ul>
<p><strong>哈希算法</strong></p>
<p>将一个新值添加到字典中时，首先根据key计算出哈希值和索引值，根据索引值将此新节点放入对应的哈希表数组上（计算索引值就是新通过哈希算法计算出一个值，再根据哈希表长度进行取模）。</p>
<p><strong>rehash步骤</strong></p>
<ol>
<li>
<p>对“备胎”分配空间</p>
<ol>
<li>如果为扩容，那么“备胎”的大小为“正主”已使用大小2倍，并“向上取整为”2的n次幂。</li>
<li>如果为缩容，那么“备胎”的大小为“正主”已使用大小的2倍。</li>
</ol>
<p>扩/缩容条件：负载因子小于0.1则缩容；负载因子大于1且目前未执行BGSAVE或BGREWRITEAOF命令，或负载因子大于5且正在执行BGSAVE或BGREWRITEAOF命令，则扩容</p>
</li>
<li>
<p>将“正主”的键值rehash到“备胎”上面。</p>
</li>
<li>
<p>“正主”所有键值都rehash到“备胎”后，将两者身份转换，并将“新备胎”初始化。</p>
</li>
</ol>
<p><strong>渐进式rehash</strong></p>
<p>将一次性复制到“备胎”的成本分摊到每次的增删改查。</p>
<p>在rehash开始时，会设置一个索引值，每次对该hash进行增删改查是，就将当前索引的数据复制到“备胎”上。</p>
<p><strong>键冲突</strong></p>
<p>使用链表来解决键冲突</p>
<h3 id="set">set</h3>
<p>当集中中的<strong>元素都是整数且元素数量小于512</strong>时，使用<strong>整数集合</strong>实现；否则使用<strong>字典</strong>实现。</p>
<h4 id="整数集合">整数集合</h4>
<p>使用整数集合时，每次添加新元素都要判断是否已存在。</p>
<p>整数集合包含三个属性：元素数组、长度、编码方式。数组中的元素<strong>按照顺序排列</strong>，且<strong>不存在重复项</strong>。</p>
<p><strong>升级</strong></p>
<p>将一个新元素添加入后，如果新元素的类型比现有的类型长时，就需要对整数集合进行升级。</p>
<ol>
<li>根据新元素的类型，扩展整数集合底层数组的大小，并为新元素分配空间</li>
<li>将底层数组现有的所有数据转换为新类型，并存入新底层数组，保持排序</li>
<li>将新元素添加到新底层数组中</li>
</ol>
<p>不支持降级。</p>
<h4 id="字典-1">字典</h4>
<p>使用字典时，value会全部被置为NULL</p>
<h3 id="sorted-set">sorted set</h3>
<p>有序集合中的元素长度都小于64字节并且元素数量小于128时使用压缩列表，否则使用跳跃表。</p>
<h4 id="压缩列表-2">压缩列表</h4>
<p>如在hash中使用压缩链表，在实现有序集合时，对于每个元素对（成员-分数）都存储为两个挨着的节点，成员在前，分数在后。且分数较小的元素对在前，分数较大的元素对在后。</p>
<h4 id="字典-2">字典</h4>
<p>在使用跳跃表实现有序集合时，也使用了字典。</p>
<p>字典中记录成员与分数的映射。这使得查找成员的分数的时间复杂度为O(1)。</p>
<p>为了节省内存，字典和跳跃表在记录成员和分数时使用并共享其地址，因此使用字典并不会多耗费内存。</p>
<h4 id="跳跃表">跳跃表</h4>
<p>如果有序集合中元素较多，或者元素的成员是比较长的字符串时，redis就会使用跳跃表来实现有序集合。</p>
<p>跳跃表包含：</p>
<ul>
<li>长度，即元素（节点）个数</li>
<li>level，即层数最大的节点的层数</li>
<li>header：头结点</li>
<li>tail：尾结点</li>
</ul>
<p>每个元素节点包含：</p>
<ul>
<li>level：每个节点在生成时都会随机分配一个层数（最大默认为32层），每层都包含前进指针和跨度。前进指针表示访问节点的地址，跨度表示前进节点和当前节点的距离。跨度实际是用来计算排位的，在查找节点的过程中，将沿途访问的节点的跨度加起来就是其排位。</li>
<li>后退指针：指向当前节点的前一个节点</li>
<li>分值：节点按所存储分值从小打到排列</li>
<li>成员对象：节点对应的数据</li>
</ul>
<p><img src="https://raw.githubusercontent.com/stong1994/images/master/picgo/20211125142306.png" alt=""></p>

  </article>
</section>

  

      </div>

      
  <footer class="footer">
    <section class="container">
      
        <p>夭寿不贰，修身以俟</p>
      
      
        ©
        
          2021 -
        
        2022
        
      
      
         · 
         <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
      
      
    </section>
  </footer>


    </main>

    
      
        
        <script src="/js/dark-mode.min.aee9c8a464eb7b3534c7110f7c5e169e7039e2fd92710e0626d451d6725af137.js"></script>
      
    

    

    

    

    

    

    

    
  </body>

</html>
