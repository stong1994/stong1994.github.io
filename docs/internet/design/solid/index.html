<!DOCTYPE html>
<html lang="zh">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Language" content="zh">
    

    
    <meta name="description" content="对于一个刚入行的程序员来说，写好的代码是很难的。这并不是说他们（或者说那时的我们）不了解编程语言的写法，也不是说他们不了解设计模式，而是说他们缺少编程思想，这种思想是需要通过经验总结出来的，也需要经验才能体会的到。SOLID原则就是面向对象编程中的一种思想的体现。
S-单一职责 全称：Single-responsiblity Principle
A class should have one and only one reason to change, meaning that a class should have only one job.
单一职责并不是说一个对象只能有一个功能，而是说一个对象应该对其使用方负责，当一方更改它时，不应该需要考虑其他使用方是否会被影响，也就是说，一个对象只能对一个使用方负责。
换句话说，一个对象不能够混合关注点。
比如说我们有一个Employee，Employee需要：
上报工作时间（ReportHours） 计薪（CalcPay） 写入到数据库（WriteEmployee）。 如果我们使用Employee实现了这三个功能，那么Employee就同时对工时汇总人员、计薪人员、员工三方负责。当我们修改计薪人员提出的bug或者功能时，就需要考虑会不会对工时汇总人员和员工产生影响。
此时，Employee违反了单一职责原则。
O-开闭原则 全称：Open-closed Principle
Objects or entities should be open for extension but closed for modification.
当产品经理提出新的需求时，应该将新业务扩展为新的对象，而不是在原有对象上修改。
比如说我们有一个Employee，它有一个计薪（CalcPay）的功能。
func (e Employee) CalcPay() float64{ return 1000 } 现在，我们需要对管理员（Admin）额外提供200块钱的补助。
func (e Employee) CalcPay() float64{ salary := float64(1000) if e.isAdmin() { salary &#43;= 200 } return salary } 这段代码有什么缺点呢？它将普通员工和负责人耦合在了一起！">
    <meta name="keywords" content="">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="SOLID原则"/>
<meta name="twitter:description" content="对于一个刚入行的程序员来说，写好的代码是很难的。这并不是说他们（或者说那时的我们）不了解编程语言的写法，也不是说他们不了解设计模式，而是说他们缺少编程思想，这种思想是需要通过经验总结出来的，也需要经验才能体会的到。SOLID原则就是面向对象编程中的一种思想的体现。
S-单一职责 全称：Single-responsiblity Principle
A class should have one and only one reason to change, meaning that a class should have only one job.
单一职责并不是说一个对象只能有一个功能，而是说一个对象应该对其使用方负责，当一方更改它时，不应该需要考虑其他使用方是否会被影响，也就是说，一个对象只能对一个使用方负责。
换句话说，一个对象不能够混合关注点。
比如说我们有一个Employee，Employee需要：
上报工作时间（ReportHours） 计薪（CalcPay） 写入到数据库（WriteEmployee）。 如果我们使用Employee实现了这三个功能，那么Employee就同时对工时汇总人员、计薪人员、员工三方负责。当我们修改计薪人员提出的bug或者功能时，就需要考虑会不会对工时汇总人员和员工产生影响。
此时，Employee违反了单一职责原则。
O-开闭原则 全称：Open-closed Principle
Objects or entities should be open for extension but closed for modification.
当产品经理提出新的需求时，应该将新业务扩展为新的对象，而不是在原有对象上修改。
比如说我们有一个Employee，它有一个计薪（CalcPay）的功能。
func (e Employee) CalcPay() float64{ return 1000 } 现在，我们需要对管理员（Admin）额外提供200块钱的补助。
func (e Employee) CalcPay() float64{ salary := float64(1000) if e.isAdmin() { salary &#43;= 200 } return salary } 这段代码有什么缺点呢？它将普通员工和负责人耦合在了一起！"/>

    <meta property="og:title" content="SOLID原则" />
<meta property="og:description" content="对于一个刚入行的程序员来说，写好的代码是很难的。这并不是说他们（或者说那时的我们）不了解编程语言的写法，也不是说他们不了解设计模式，而是说他们缺少编程思想，这种思想是需要通过经验总结出来的，也需要经验才能体会的到。SOLID原则就是面向对象编程中的一种思想的体现。
S-单一职责 全称：Single-responsiblity Principle
A class should have one and only one reason to change, meaning that a class should have only one job.
单一职责并不是说一个对象只能有一个功能，而是说一个对象应该对其使用方负责，当一方更改它时，不应该需要考虑其他使用方是否会被影响，也就是说，一个对象只能对一个使用方负责。
换句话说，一个对象不能够混合关注点。
比如说我们有一个Employee，Employee需要：
上报工作时间（ReportHours） 计薪（CalcPay） 写入到数据库（WriteEmployee）。 如果我们使用Employee实现了这三个功能，那么Employee就同时对工时汇总人员、计薪人员、员工三方负责。当我们修改计薪人员提出的bug或者功能时，就需要考虑会不会对工时汇总人员和员工产生影响。
此时，Employee违反了单一职责原则。
O-开闭原则 全称：Open-closed Principle
Objects or entities should be open for extension but closed for modification.
当产品经理提出新的需求时，应该将新业务扩展为新的对象，而不是在原有对象上修改。
比如说我们有一个Employee，它有一个计薪（CalcPay）的功能。
func (e Employee) CalcPay() float64{ return 1000 } 现在，我们需要对管理员（Admin）额外提供200块钱的补助。
func (e Employee) CalcPay() float64{ salary := float64(1000) if e.isAdmin() { salary &#43;= 200 } return salary } 这段代码有什么缺点呢？它将普通员工和负责人耦合在了一起！" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://stong1994.github.io/internet/design/solid/" /><meta property="article:section" content="internet" />
<meta property="article:published_time" content="2022-11-04T17:23:00+08:00" />
<meta property="article:modified_time" content="2022-11-04T17:23:00+08:00" />



    <title>
  SOLID原则 · 北人
</title>

    
      <link rel="canonical" href="https://stong1994.github.io/internet/design/solid/">
    

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700&display=swap" rel="stylesheet">
    <link rel="preload" href="/fonts/forkawesome-webfont.woff2?v=1.1.7" as="font" type="font/woff2" crossorigin>

    
      
      
      <link rel="stylesheet" href="/css/coder.min.5317d5aa4161466b8ec88da2b36cacd596a0fdc1cc6a986e05f9b413df8ad2d3.css" integrity="sha256-UxfVqkFhRmuOyI2is2ys1Zag/cHMaphuBfm0E9&#43;K0tM=" crossorigin="anonymous" media="screen" />
    

    

    
      
        
        
        <link rel="stylesheet" href="/css/coder-dark.min.126ad3988d46bdae6217a11105b53c9662bca05f39d42d3c0fb366919d334620.css" integrity="sha256-EmrTmI1Gva5iF6ERBbU8lmK8oF851C08D7NmkZ0zRiA=" crossorigin="anonymous" media="screen" />
      
    

    

    

    <link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

    <link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

    
      <script defer src="https://twemoji.maxcdn.com/v/13.0.1/twemoji.min.js"
        integrity="sha384-5f4X0lBluNY/Ib4VhGx0Pf6iDCF99VGXJIyYy7dDLY5QlEd7Ap0hICSSZA1XYbc4" crossorigin="anonymous"></script>
    

    <meta name="generator" content="Hugo 0.101.0" />
  </head>

  
  
    
  
  <body class="colorscheme-auto"
        onload=" twemoji.parse(document.body); "
  >
    
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      北人
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/internet/">计算机与互联网</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/cloudnative/">云原生</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/web3/">区块链&amp;web3</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/book/">读书</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/life/">生活</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/mental_model/">心智模型</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/about/">关于</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


      <div class="content">
        
    <div id="toc" class="well col-md-4 col-sm-6">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#s-单一职责">S-单一职责</a></li>
    <li><a href="#o-开闭原则">O-开闭原则</a></li>
    <li><a href="#l-里氏替换">L-里氏替换</a></li>
    <li><a href="#i-接口隔离">I-接口隔离</a></li>
    <li><a href="#d-依赖倒置">D-依赖倒置</a></li>
    <li><a href="#总结">总结</a></li>
    <li><a href="#相关文档">相关文档</a></li>
  </ul>
</nav>
    </div>
  <section class="container page">
  <article>
    <header>
      <h1>SOLID原则</h1>
    </header>

    <p>对于一个刚入行的程序员来说，写好的代码是很难的。这并不是说他们（或者说那时的我们）不了解编程语言的写法，也不是说他们不了解设计模式，而是说他们缺少编程思想，这种思想是需要通过经验总结出来的，也需要经验才能体会的到。SOLID原则就是面向对象编程中的一种思想的体现。</p>
<h2 id="s-单一职责">S-单一职责</h2>
<p>全称：Single-responsiblity Principle</p>
<blockquote>
<p>A class should have one and only one reason to change, meaning that a class should have only one job.</p>
</blockquote>
<p>单一职责并不是说一个对象只能有一个功能，而是说<strong>一个对象应该对其使用方负责，当一方更改它时，不应该需要考虑其他使用方是否会被影响，也就是说，一个对象只能对一个使用方负责。</strong></p>
<p>换句话说，<strong>一个对象不能够混合关注点</strong>。</p>
<p>比如说我们有一个Employee，Employee需要：</p>
<ul>
<li>上报工作时间（ReportHours）</li>
<li>计薪（CalcPay）</li>
<li>写入到数据库（WriteEmployee）。</li>
</ul>
<p>如果我们使用Employee实现了这三个功能，那么Employee就同时对工时汇总人员、计薪人员、员工三方负责。当我们修改计薪人员提出的bug或者功能时，就需要考虑会不会对工时汇总人员和员工产生影响。</p>
<p>此时，Employee违反了单一职责原则。</p>
<h2 id="o-开闭原则">O-开闭原则</h2>
<p>全称：Open-closed Principle</p>
<blockquote>
<p>Objects or entities should be open for extension but closed for modification.</p>
</blockquote>
<p>当产品经理提出新的需求时，应该<strong>将新业务扩展为新的对象，而不是在原有对象上修改</strong>。</p>
<p>比如说我们有一个Employee，它有一个计薪（CalcPay）的功能。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> (e Employee) CalcPay() <span style="color:#fff;font-weight:bold">float64</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">1000</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>现在，我们需要对管理员（Admin）额外提供200块钱的补助。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> (e Employee) CalcPay() <span style="color:#fff;font-weight:bold">float64</span>{
</span></span><span style="display:flex;"><span>  salary := <span style="color:#fff;font-weight:bold">float64</span>(<span style="color:#ff0;font-weight:bold">1000</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">if</span> e.isAdmin() {
</span></span><span style="display:flex;"><span>    salary += <span style="color:#ff0;font-weight:bold">200</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">return</span> salary
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这段代码有什么缺点呢？<strong>它将普通员工和负责人耦合在了一起！</strong></p>
<ul>
<li>如果又多了一个角色，比如说主管，这里又要多一个<code>if/else</code>，而不断叠加的<code>if/else</code>则会让代码愈发的臃肿。</li>
<li>新添加的角色的代码和已有角色的代码耦合在一起，在编写代码的同时，也会影响已有的角色的代码。</li>
<li>如果我们需要对管理员增加其他行为，这时要抽象为Admin，则需要将其<code>CalcPay</code>抽出来，这时就需要小心是否会影响到普通员工的行为。</li>
</ul>
<p>耦合的缺点要比我能列出来的多很多。</p>
<p>正确的做法应该是扩展一个新的角色：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">type</span> Admin <span style="color:#fff;font-weight:bold">struct</span>{}
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> (a Admin) CalcPay() <span style="color:#fff;font-weight:bold">float64</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">1000</span> + <span style="color:#ff0;font-weight:bold">200</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果我们需要为公司的所有人计薪，则可以将所有人都抽象为<code>CalcPayUser</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">type</span> CalcPayUser <span style="color:#fff;font-weight:bold">interface</span> {
</span></span><span style="display:flex;"><span>	CalcPay() <span style="color:#fff;font-weight:bold">float64</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> CalcAllUser(users []CalcPayUser) {
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">for</span> _, user := <span style="color:#fff;font-weight:bold">range</span> users {
</span></span><span style="display:flex;"><span>    salry := user.CalcPay()
</span></span><span style="display:flex;"><span>    fmt.Println(salary)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="l-里氏替换">L-里氏替换</h2>
<p>全称：Liskov Substitution Principle</p>
<blockquote>
<p>Derived classes must be usable through the base class interface, without the need for the user to know the difference.</p>
</blockquote>
<p>里氏替换对衍生对象提出了要求：<strong>衍生对象及其继承的方法必须是可用的，且对用户来说是没有区别的（不需要用户区别处理）。</strong></p>
<p>比如说我们已经有了一个长方形，它有长和宽两个属性，也有设置长和宽的两个方法和计算面积的方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">type</span> rectangle <span style="color:#fff;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	height <span style="color:#fff;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>	width <span style="color:#fff;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> (r *rectangle) SetHeight(height <span style="color:#fff;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>  r.height = height
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> (r *rectangle) SetWidth(width <span style="color:#fff;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>  r.width = width
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> (r rectangle) Area() <span style="color:#fff;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">return</span> r.height * r.width
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>现在我们想要一个正方形，然后我们让正方形&quot;继承&quot;了长方形。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">type</span> square <span style="color:#fff;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	rectangle
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> (s square) Area() <span style="color:#fff;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">return</span> s.height * s.width
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> (s *square) SetHeight(height <span style="color:#fff;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>  s.height = height
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> (s *square) SetWidth(width <span style="color:#fff;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>  s.width = width
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>现在正方形已经实现了长方形的三个方法已经。但是因为正方形的长度等于宽度，因此在使用方使用时，需要注意区分形状，并做不同的处理：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> (s Shape) SetHeight(height <span style="color:#fff;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">if</span> s.isRectangle {
</span></span><span style="display:flex;"><span>    s.SetHeight(height)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">if</span> s.isSquare {
</span></span><span style="display:flex;"><span>    s.SetHeight(height)
</span></span><span style="display:flex;"><span>    s.SetWidth(height)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> (s Shape) SetWidth(height <span style="color:#fff;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">if</span> s.isRectangle {
</span></span><span style="display:flex;"><span>    s.SetWidth(height)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">if</span> s.isSquare {
</span></span><span style="display:flex;"><span>    s.SetHeight(height)
</span></span><span style="display:flex;"><span>    s.SetWidth(height)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这就违反了里氏替换原则。</p>
<p><strong>如果代码违反了里氏替换原则，说明衍生对象不应该继承/组合基础对象，应考虑其他写法。</strong></p>
<h2 id="i-接口隔离">I-接口隔离</h2>
<p>全称：Interface Segregation Principle</p>
<blockquote>
<p>A client should never be forced to implement an interface that it doesn’t use, or clients shouldn’t be forced to depend on methods they do not use.</p>
</blockquote>
<p>接口隔离是指导接口之间进行隔离的一个原则：**不能强迫一个对象实现它不需要的接口，也不能强迫它一来它不需要的方法。**所以在抽象接口时，要注意划分。</p>
<p>比如Admin实现了IUser接口, IUser有获取ID和禁用员工两个方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">type</span> IUser <span style="color:#fff;font-weight:bold">interface</span>{
</span></span><span style="display:flex;"><span>  GetID() <span style="color:#fff;font-weight:bold">string</span>
</span></span><span style="display:flex;"><span>  ForbiddenUser(user <span style="color:#fff;font-weight:bold">string</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>现在我们需要一个Employee，它有User的性质，因此也实现了IUser，但是Employee没有禁用员工的行为，因此没有办法实现这个方法。</p>
<p>我们应该如何处理？实现ForbiddenUser但是不处理吗？如果这样，就违反了接口隔离原则！</p>
<p>我们应该将接口细化、划分为多个接口：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">type</span> IUser <span style="color:#fff;font-weight:bold">interface</span>{
</span></span><span style="display:flex;"><span>	GetID() <span style="color:#fff;font-weight:bold">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">type</span> IAdmin <span style="color:#fff;font-weight:bold">interface</span>{
</span></span><span style="display:flex;"><span>	IUser
</span></span><span style="display:flex;"><span>  ForbiddenUser(user <span style="color:#fff;font-weight:bold">string</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这样，对于Employee和Admin，都有其“恰好所需”的接口来实现。</p>
<h2 id="d-依赖倒置">D-依赖倒置</h2>
<p>全称：Dependency Inversion Principle</p>
<blockquote>
<p>Entities must depend on abstractions, not on concretions. It states that the high-level module must not depend on the low-level module, but they should depend on abstractions.</p>
</blockquote>
<p>依赖倒置是指导服务内层级划分的一个准则——<strong>上层模块不应依赖下层模块，而应该依赖于它们的接口。其核心理念是上层模块不应该关心下层模块的实现细节。</strong></p>
<p>依赖倒置这一原则在很多模式中都有体现，比如说仓库模式（Repository Pattern）。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">type</span> IRepo <span style="color:#fff;font-weight:bold">interface</span>{
</span></span><span style="display:flex;"><span>  GetUser(id <span style="color:#fff;font-weight:bold">string</span>) User
</span></span><span style="display:flex;"><span>  GetCompany(id <span style="color:#fff;font-weight:bold">string</span>) Company
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>业务对象或者领域对象依赖于IRepo接口，而不关心底层数据库是用MySQL还是MongoDB亦或Redis，也不关心它们的SQL语句、实现细节。</p>
<p>业务对象只关心它需要什么数据，IRepo则按需提供即可。<strong>其核心理念是业务对象只关心自己的业务规则，尽可能最大程度的降低业务方法的复杂程度。</strong></p>
<h2 id="总结">总结</h2>
<ul>
<li>原则之间并不是互斥的，实际中的问题可能同时违反了多个原则。</li>
<li>文中只给出了错误的使用，并且没有提供纠错实例。这样做是因为解决问题的方式有很多种，举例反而容易造成固化解决方式的误解（如，认为这种问题只能这样解决）。</li>
<li>代码需要不断被重构，写代码也需要不断精进。</li>
</ul>
<h2 id="相关文档">相关文档</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=zHiWqnTWsn4&amp;ab_channel=FucktheCommunism">bob大叔亲自讲解SOLID</a></li>
<li><a href="https://www.digitalocean.com/community/conceptual-articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design">SOLID原则-digitalocean</a></li>
</ul>

  </article>
</section>

  

      </div>

      
  <footer class="footer">
    <section class="container">
      
        <p>夭寿不贰，修身以俟</p>
      
      
        ©
        
          2021 -
        
        2022
        
      
      
         · 
         <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
      
      
    </section>
  </footer>


    </main>

    
      
        
        <script src="/js/dark-mode.min.c2d8a1f8f2660e4a46d776277c72695a1e0ca65939d79f754441d47551604af5.js"></script>
      
    

    

    

    

    

    

    

    
  </body>

</html>
