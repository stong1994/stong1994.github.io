<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>北人</title>
    <link>https://stong1994.github.io/internet/</link>
    <description>Recent content on 北人</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Sun, 27 Mar 2022 21:19:00 +0800</lastBuildDate><atom:link href="https://stong1994.github.io/internet/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Manacher算法</title>
      <link>https://stong1994.github.io/internet/algorithm/manacher/</link>
      <pubDate>Sat, 12 Feb 2022 16:32:00 +0800</pubDate>
      
      <guid>https://stong1994.github.io/internet/algorithm/manacher/</guid>
      <description>Manacher算法是什么 Manacher算法俗称马拉车算法，用于解决在一个字符串中找到最长的回文子串问题。
回文串”是一个正读和反读都一样的字符串，如level，noon等都是回文串。
基础思路-中心扩展 为了找到最长的回文串，需要先找到回文串的中心，然后从中心向外扩展。
// 例如我们找到中心处的索引为mid,那么找到以mid为中心的回文串的逻辑代码为： func findPalindrome(s string, mid int) string{ l,r := mid-1, mid+1 for ; l &amp;gt;= 0 &amp;amp;&amp;amp; r &amp;lt; len(s); l,r = l-1, r+1 { if s[l] != s[r] { break } } return s[l+1: r] } 需要注意中心处可能是一个元素（如aba），也可能是两个元素（如abba）。所以上述函数要优化为
func findPalindrome(s string, l, r int) string { for ; l &amp;gt;= 0 &amp;amp;&amp;amp; r &amp;lt; len(s); l,r = l-1, r+1 { if s[l] != s[r] { break } } return s[l+1: r] } 那么一个完整的找最长回文子串的算法为</description>
    </item>
    
    <item>
      <title>KMP算法</title>
      <link>https://stong1994.github.io/internet/algorithm/kmp/</link>
      <pubDate>Fri, 28 Jan 2022 16:32:00 +0800</pubDate>
      
      <guid>https://stong1994.github.io/internet/algorithm/kmp/</guid>
      <description>背景 在做LeetCode第572题——另一颗树的子树时，我看到题解上说可以用KMP算法来解决。虽然以前了解过KMP算法，但是遇到问题时还是对算法的思路、如何实现一头雾水，因此写篇文章总结下。
KMP是什么 KMP是由三位作者的名称首字母组成的单词。KMP的目的是解决子串查找问题。
KMP演化 如果只看KMP算法的代码，会很难理解，因此我们从头来演化KMP的思路。
既然KMP算法要解决的是子串查找问题，那我们就从最无脑的暴力破解算法说起。在此之前，我们要规定几个概念。
基础概念  模式字符串：要匹配的字符串模板。通常是在初始化时处理的数据。 匹配字符串：要根据模式字符串去匹配的目的字符串。通常是输入数据。往往需要找到和模式字符串相同的子串的首字母索引——即在匹配字符串中找到模式字符串。  最无脑的算法 把匹配字符串看做是一把完整的尺子，把模式字符串看做是一把残尺。尺子上的刻度数字都是随机数字。
固定好完整的尺子，将残尺从完整的尺子的第一个刻度处开始比较，如果不匹配就把残尺往后移动一位。直到找到匹配的位置。
func violentSearchSubStr(txt, pat string) int { for i := 0; i &amp;lt; len(txt) - len(pat)+1; i++ { j := 0 for ; j &amp;lt; len(pat); j++ { if txt[i+j] != pat[j] { break } } if j == len(pat) { return i } } return -1 } 利用已有的经验——部分匹配表PMT 在“最无脑的算法”中，每次匹配失败都会将残尺往后移动一位。假设残尺上有10个数字，匹配失败时是在匹配第10个数字时失败，那么这10次匹配经验就浪费掉了。
模式字符串的前四个数字为3153，最后匹配的匹配字符串的四个字符串也是3153，因此，我们可以直接将残尺的3153和完整尺的3153对齐，即可以直接移动六位。
显然，利用历史经验一次性移动六位要比移动一位的效率高很多。那么如何利用这些匹配经验，将残尺多移动几位？
于是问题转换为：假设残尺需要移动的位数为M，移动后残尺的前N位能够匹配，如何利用已知条件求出最大的M？
大佬们为此设计了部分匹配表（Partial Match Table）：PMT是一个数组，长度与模式字符串相同。每个元素对应的是其在模式字符串对应的字符串前缀中前后对称的字符的个数。例如：对于第4个元素来说，其对应的模式字符串前缀为3153，其前后对称的字符为3，个数为1；对于第5个元素来说，其对应的模式字符串的前缀为31531，其前后对称的字符为3和1，个数为2，因此可以得到PMT：</description>
    </item>
    
    <item>
      <title>理解事务：InnoDB的ACID</title>
      <link>https://stong1994.github.io/internet/mysql/acid/</link>
      <pubDate>Sun, 16 Jan 2022 17:05:00 +0800</pubDate>
      
      <guid>https://stong1994.github.io/internet/mysql/acid/</guid>
      <description>事务对于数据库而言是非常重要的，事务能够保证我们的软件世界是稳定的——从一个状态到另外一个状态是符合人们预期的。而为了能够保证一个事件在任何情况下都能符合人们的预期，我们总结出事务需要满足四个特性：原子性、一致性、隔离性、持久性。
每种数据库对于事务的实现都不同，有的数据库，如Redis，没有实现所有的事务特性，而目前比较火的分布式数据库，也有自己的实现特性——BASE。但理解事务的特性仍是软件开发行业从业者的基础素质。
本篇会以InnoDB为例，来探究它是如何实现事务的。
事务id的生成 事务id的生成规则与row_id的生成规则不能说相似，只能说一模一样。
 服务器在内存中维护一个全局变量，每当需要为某个事务分配事务id时，获取这个变量作为row_id的值，并把这个全局变量自增1 每当全局变量的值变为256的倍数时，就会将该变量写入系统表空间中 当系统启动时，将系统表空间中的该变量加上256加载到内存中（加256是为了确保内存中的值一定比记录中已存在的事务id值大）  原子性（Atomicity）  一个事务内的执行语句要么全执行，要么都不执行。可以理解为一个事务内的多个事件，如果有一个事件发生异常，就要回退到第一个事件发生前的状态。
 原子性要求我们可以对执行事务过程中改变的数据进行回滚，而为了实现回滚，InnoDB使用了undo log。
undo log 一个索引除了会产生叶子结点段和非叶子结点段之外，还会产生回滚段。我们的undo log就是存放在回滚段中。
对于每条记录，都会存在两个隐藏列：trx_id和roll_pointer。每次新增undo log时，会在新纪录上更新roll_pointer，指向新的undo log，而undo log也会记录旧记录上的roll_pointer，这样，以新纪录开始，与仍存在的旧记录形成了一条版本链。undo log上的旧记录可能不会记录所有的数据，如更新操作产生的日志就是只记录被更新的字段，但是通过遍历版本链就能找到旧记录的所有字段。
向表中插入/更新/删除一条记录时，需要对聚簇索引和所有二级索引都进行插入/更新/删除，但是在记录undo log时，我们只需要针对聚簇索引来记录。聚簇索引和二级索引都是一一对应的，在回滚时，根据主键信息对所有的二级索引都进行回滚即可。所以，只有聚簇索引才会存在回滚段。
对于插入操作 插入操作的回滚操作就是删除操作，因此，在undo log中记录插入记录的主键即可。
对于删除操作 删除操作的逆操作插入操作，按道理来说，undo log中会记录被删除的数据，但是InnoDB没有这样做。因为如果数据被删了，那么“其他人”就看不到了，先于这个事务执行的事务就可能会产生不可重复读或者幻读。
InnoDB中的实现是这样：
 第一阶段，将这个记录的deleted_flag（每个记录都有的隐藏列）标识为1，这就意味着这条记录正在删除中。同时，在undo log中需要记录索引各列的信息，用于后续的purge操作。 第二阶段，在事务提交后，会有专门的线程来把这条记录删除掉——把这条记录从正常记录链表中删除，并加入到垃圾链表中  对于更新操作 更新操作需要分为两种情况：更新主键、不更新主键
不更新主键 如果不更新主键，并且更新前后这条记录的各个字段占用的空间都不变，那么直接将变更的旧字段写到undo log即可。
如果更新后字段占用的空间有变化，那么就要删除这条旧记录，并将其放入“垃圾链表”中（并不是标记删除），如果新记录占用的空间小于旧记录，则可以“复用”旧记录的空间，否则需要重新申请一块空间来存放新记录。
undo log会记录更新的列的旧数据，以供回滚。
更新主键 如果要更新主键，那么就相当于先进行删除操作，再进行插入操作。即先对旧记录进行标记删除，再插入新数据，同时产生两条undo log。
undo log在崩溃恢复时的作用 服务器在崩溃后的恢复过程中，首先根据redo log将各个页面的数据恢复到之前的状态，但是有些没有提交的redo log可能已经被刷盘，因此未提交的事务修改过的页面也被恢复了。这时需要把这些页面回滚掉。
通过系统表空间定位到回滚段的位置，并找到状态为TRX_UNDO_ACTIVE的undo log链表，这意味着存在活跃的事务正在向这个undo log链表写入undo log，找到对应的事务id，并将其做出的修改全部回滚掉。
一致性（Consistency） 关于一致性，似乎没有统一的说法，有的说ACID中的C是用来凑数的，一致性是事务要达到的目的，而不是事务特性；有的说一致性就是数据库对于数据的约束，如非空、唯一等；有的说一致性要由业务逻辑的程序来维持。不用纠结这些。
另外，区别于分布式数据库中的最终一致性，InnoDB中的一致性指的是强一致性。
隔离性（Isolation）  事务之间应该是隔离的、互不影响的。
 业内的隔离性划分（非InnoDB） 四种隔离问题  脏写：一个事务修改了另一个未提交的事务的数据 脏读：一个事务读取了另一个未提交的事务修改后的数据 不可重复读：一个事务两次读取同一条记录的数据不同，因为被另一个事务修改 幻读：一个事务两次读取的范围数据不同，因为被另一个事务进行了插入/更新操作  四种隔离级别  读未提交：只解决脏写问题 读已提交：解决脏写、脏读问题 可重复读：解决脏写、脏读、不可重复度问题 串行化：解决全部四个问题  三种锁  排它锁：对于同一条记录，只有一个事务能够修改 共享锁：对于同一条记录，多个事务都能读取，但不允许修改 范围锁：一个范围内的记录的共享锁  他们之间的关系    使用的锁 隔离问题 隔离级别     不用锁 未解决：脏写、脏读、不可重复度、幻读 无，脏写问题是必须要避免的   排它锁 只解决脏写 读未提交   排它锁+（读完就释放的）共享锁 解决脏写、脏读 读已提交   排它锁+（事务执行完才释放的）共享锁 解决脏写、脏读、不可重复读 可重复读   排它锁+共享锁+范围锁 解决脏写、脏读、不可重复读、幻读 串行化    由上可以看出，是由于使用的锁不同，进而产生了隔离问题、隔离级别！</description>
    </item>
    
    <item>
      <title>InnoDB存储引擎的物理结构</title>
      <link>https://stong1994.github.io/internet/mysql/InnoDB_struct/</link>
      <pubDate>Mon, 03 Jan 2022 13:32:00 +0800</pubDate>
      
      <guid>https://stong1994.github.io/internet/mysql/InnoDB_struct/</guid>
      <description>要了解使用InnoDB存储引擎进行CRUD时发生了什么，怎么也绕不过其物理结构，于是在这里记录下。
只记录关键信息，能支持理解CRUD与事务特性即可
关于取舍 作为一个通用的数据存储方案，需要考虑很多问题，这些问题包括如何占用更少的磁盘、内存，如何提高CRUD的速度，如何保证数据的一致性等待。
作为一个通用的方案，就一定要对这些问题进行取舍，而在InnoDB的设计中，可以看到其**优先考虑减少磁盘随机IO，然后是占用更少的磁盘空间。**而为了支持事务的特性，而引入了undo log和redo log等组件，导致整体设计上的复杂度很高。看完InnoDB的设计，再对比redis的设计，就能感慨redis的简洁，但是这不代表redis的设计更优雅，每个组件的定位不同，使用场景也不同，设计上自然也就不同。
磁盘 页 页是InnoDB最基本的存储单位。
页由File Header、Page Header、Infimum+Supremum、UserRecords、Free Space、Page Directory、File Trailer组成。
File Header File Header通用于各种类型的页，用户记录页号、页类型、校验和、所属表空间、上下页的页号等。
这些页通过上下页的页号构建了一个双向链表，无需这些页在物理上真正连着。
File Trailer File Trailer由8字节组成。
前4个字节表示页的校验和，此校验和应该与File Header的校验和相等，如果不等，说明刷新页的过程被中断了，如断电。
后4个字节表示页面最后修改时对应的LSN的后4字节，正常情况下与File Header的Fil_PAGE_LSN的后4字节相同。也是用来校验页的完整性的。
Page Header Page Header用来存储页的状态，如存储的记录条数、槽的数量、Free Space在页面的地址偏移量等。
User Record 和 Free Space User Record和Free Space组成了页的剩余部分，每次插入数据时，都会从Free Space申请一部分空间划到User Record中。
在User Record中是一条条紧密相邻的记录。记录中包括一些控制信息，比如记录是否被删除、下一条记录的相对位置（next_record）等。
通过next_record，页中的记录组成了一个单向链表，链表是根据主键大小由小到大按顺序连接的，因此为了更快的找到最大值和最小值，页中又引入了两个虚拟记录——最大记录（Supremum）和最小记录(Infimum)。
Page Directory 如果没有页目录，那么查找一条数据只能遍历查找，所以InnoDB引入了页目录。
页目录只记录每组记录的最大值，这些最大值在页目录中被称为槽(Slot)，槽在页目录中也是从小到大按顺序存放的。
记录的分组规则：
 最开始时只有两个虚拟记录Supremum和Infimum，各自占一个槽。 插入数据时，找到比插入数据大的第一个槽（二分法），将其插入到这个组中。  如果插入后该组的记录数大于8个，那么就将这个槽拆分成两个组，并在页目录中增加一个槽，其中小槽中分配到的记录数为5条，大槽中分配到的记录数为4条。    由上可知分组的记录特色：
 第一个槽Infimum只有其自身一条记录 最后一个槽Supremum记录数为1-8条 中间槽的记录数为4-8条  在页中查找一条记录时：
 通过二分法确定该记录所在的槽（先找到比该记录主键大的第一个槽，再找到上一个槽，根据其next_record找到记录所在槽的最小记录地址） 通过next_record遍历该组中的各个记录  索引 在查询数据时，首先需要定位数据存在于哪个页时，虽然通过遍历数据页组成的链表查询到，但性能太差，因此引入了索引。</description>
    </item>
    
    <item>
      <title>如何写没有bug的代码</title>
      <link>https://stong1994.github.io/internet/how_to_code_without_bug/</link>
      <pubDate>Sat, 04 Dec 2021 23:31:51 +0800</pubDate>
      
      <guid>https://stong1994.github.io/internet/how_to_code_without_bug/</guid>
      <description>作为一名程序员，bug就是我们生活的一部分。 一听到有bug，绝大分程序员的血压会立马上升，紧接着心脏跳动加快，然后带着一丝侥幸的期待着这是个</description>
    </item>
    
    <item>
      <title>查询、插入、删除、更新一条MySQL记录都经历了什么</title>
      <link>https://stong1994.github.io/internet/MySQL/curd/</link>
      <pubDate>Wed, 06 Oct 2021 17:05:00 +0800</pubDate>
      
      <guid>https://stong1994.github.io/internet/MySQL/curd/</guid>
      <description>一直对MySQL这个黑盒子是如何运行的不甚清楚，因此在这里总结下。
先来了解下MySQL体系架构。
MySQL体系架构 图片来自: https://segmentfault.com/a/1190000039693313
以上图为对照，MySQL的查询会经历大致以下过程：
 客户端与服务端建立连接 查询缓存 将请求的SQL进行解析，并进行语法校验 通过优化器来优化SQL，生成执行计划 选择对应的存储引擎来执行计划，获取数据 向客户端返回查询结果  那么我们就来分别看看这几步都做了哪些事情。
建立连接 客户端与服务端的连接本质上是进程间的通信，进程之间的通信方式有：管道、命名管道、命名字、TCP/IP套接字、UNIX域套接字。我们只讨论最常见的TCP/IP套接字。
mysql -h 127.0.0.1 -u root -p 连接时会查询mysql.user表进行权限校验。
 MySQL的通信协议是半双工的——在任意时刻，要么客户端向服务端发送数据，要么服务端向客户端发送数据。
 查询缓存 如果操作为查询，并且MySQL服务器开启了查询缓存，那么MySQL服务器会对sql进行缓存命中。
这个缓存是由大小写敏感的哈希查找实现的，对sql的任何改动都会导致不能命中缓存。
解析sql 在这一步会校验sql是否符合语法，并将sql解析为token。
查询优化 MySQL使用基于成本的优化器。成本分为IO成本和CPU成本，MySQL会定义每种操作对应的代价。大致流程为：
 根据搜索条件，找出所有可能使用的索引 计算全表扫描的代价 计算使用不同索引执行查询的代价 对比各种方案，选择成本最低的那个  执行语句 只讨论增删改查。
读取记录的过程 缓存都做了什么 InnoDB是以页为单位进行磁盘IO的，如果每次读取都要从磁盘读取，那么性能会很差。因此引入了缓存池——BufferPool，而从磁盘中加载到缓冲池中的页我们称为缓冲页。
每次读取数据页时，都从一个哈希表（key为表空间号+页号，value为控制块）中定位到缓冲页对应的控制块，如果不存在，则从磁盘进行读取，如果存在，则直接读取缓存。
每次从磁盘读取数据页时，都会在Buffer Pool中的free链表中获取空闲页，并填充缓冲页对应的控制块（我们需要这个结构来快速定位到目标缓冲页）。
InnoDB还引入了LRU链表来淘汰最近最少使用的缓冲页（参考InnoDB中的LRU链表）。
在聚簇索引中定位一条记录 通过索引页定位数据页  在索引页中，通过二分法定位记录所在的槽，这个槽对应着索引所在的索引记录组。（索引记录被分成多组，每组的最小值存入Page Directory，称为槽slot） 在索引记录组中通过next_record字段来遍历整个组，找到记录所在的索引页数据（主键+页号） 通过页号找到下一层树的目标索引页 重复上述3个步骤，直到找到最后一层树——即数据页  在数据页中定位目标记录  在数据页中找到Page Directory，通过二分法定位目标记录所在的槽（记录被分成多组，每组的最大值（思考为什么是最大值而不是最小值）存入Page Directory，称为槽slot） 通过Page Directory找到上一个槽，其对应的记录为该组的最大值，然后通过next_record来找到目的槽中的最小值，接着通过next_record来遍历整个目的组找到目标记录。  在二级索引中定位一条记录 定位方式同聚簇索引相同，不同之处在于二级索引中的数据页存储的是主键而不是完整的记录，因此需要通过主键进行回表查询。
锁和事务 事务中不加锁的读 在事务中，如果读操作没有加锁，那么会生成一个ReadView来保证每次读到事务开始前已提交的数据（可重复读的隔离级别下每个事务中的多次读取复用同一个ReadView，读已提交的隔离界别下每次读取都会生成一个新的ReadView）</description>
    </item>
    
    <item>
      <title>DDD实战-笔记篇</title>
      <link>https://stong1994.github.io/internet/ddd/practise/</link>
      <pubDate>Fri, 29 Jan 2021 23:31:51 +0800</pubDate>
      
      <guid>https://stong1994.github.io/internet/ddd/practise/</guid>
      <description>DDD实战 如何构建中台业务模型？ 1. 自顶向下的策略 这种策略是先做顶层设计，从最高领域逐级分解为中台，分别建立领域模型，根据业务属性分为通用中台或核心中台。领域建模过程主要基于业务现状，暂时不考虑系统现状。自顶向下的策略适用于全新的应用系统建设，或旧系统推倒重建的情况。
2. 自底向上的策略 这种策略是基于业务和系统现状完成领域建模。首先分别完成系统所在业务域的领域建模；然后对齐业务域，找出具有同类或相似业务功能的领域模型，对比分析领域模型的差异，重组领域对象，重构领域模型。这个过程会沉淀公共和复用的业务能力，会将分散的业务模型整合。自底向上策略适用于遗留系统业务模型的演进式重构。
第一步：锁定系统所在业务域，构建领域模型。 锁定系统所在的业务域，采用事件风暴，找出领域对象，构建聚合，划分限界上下文，建立领域模型。
可以看到有很多相似的模块
第二步：对齐业务域，构建中台业务模型 传统核心领域模型明显多于左侧的互联网电商。这个结论也给我们指明了一个方向：首先我们可以将传统核心的领域模型作为主领域模型，将互联网电商领域模型作为辅助模型来构建中台业务模型。然后再将互联网电商中重复的能力沉淀到传统核心的领域模型中，只保留自己的个性能力，比如订单。中台业务建模时，既要关注领域模型的完备性，也要关注不同渠道敏捷响应市场的要求。
我们从互联网电商和传统核心的领域模型中，归纳并分离出能覆盖两个域的所有业务子域。通过分析，我们找到了用户、客户、承保、收付和订单五个业务域，它们是可以用于领域模型对比分析的基准域。
构建多业务域的中台业务模型的过程，就是找出同一业务域内所有同类业务的领域模型，对比分析域内领域模型和聚合的差异和共同点，打破原有的模型，完成新的中台业务模型重组或归并的过程。
重构后
构建中台模型的要点 分域建模型，找准基准域，划定上下文，聚合重归类
第三步：中台归类，根据领域模型设计微服务。 完成中台业务建模后，我们就有了下面这张图。从这张图中我们可以看到总共构建了多少个中台，中台下面有哪些领域模型，哪些中台是通用中台，哪些中台是核心中台，中台的基本信息等等，都一目了然。你根据中台下的领域模型就可以设计微服务了。
重构过程中的领域对象 部分领域对象可能会根据新的业务要求，从原来的聚合中分离，重组到其它聚合。新领域模型的领域对象，比如实体、领域服务等，在重组后可能还会根据新的业务场景和需求进行代码重构。
事件风暴需要准备些什么 1. 事件风暴的参与者 除了领域专家，事件风暴的其他参与者可以是 DDD 专家、架构师、产品经理、项目经理、开发人员和测试人员等项目团队成员。
领域建模是统一团队语言的过程，因此项目团队应尽早地参与到领域建模中，这样才能高效建立起团队的通用语言。
2. 事件风暴要准备的材料 事件风暴参与者会将自己的想法和意见写在即时贴上，并将贴纸贴在墙上的合适位置，我们戏称这个过程是“刷墙”。所以即时贴和水笔是必备材料，另外，你还可以准备一些胶带或者磁扣，以便贴纸随时能更换位置。
值得提醒一下的是，在这个过程中，我们要用不同颜色的贴纸区分领域行为。如下图，我们可以用蓝色表示命令，用绿色表示实体，橙色表示领域事件，黄色表示补充信息等。补充信息主要用来说明注意事项，比如外部依赖等。颜色并不固定，这只是我的习惯，团队内统一才是重点。
3. 事件风暴的场地 只需要一堵足够长的墙和足够大的空间就可以了。墙是用来贴纸的，大空间可以让人四处走动，方便合作。撤掉会议桌和椅子的事件风暴，你会发现参与者们的效率更高。
4. 事件风暴分析的关注点 在领域建模的过程中，我们需要重点关注这类业务的语言和行为。比如某些业务动作或行为（事件）是否会触发下一个业务动作，这个动作（事件）的输入和输出是什么？是谁（实体）发出的什么动作（命令），触发了这个动作（事件）…我们可以从这些暗藏的词汇中，分析出领域模型中的事件、命令和实体等领域对象。
如何用事件风暴构建领域模型 1. 产品愿景 产品愿景的主要目的是对产品顶层价值的设计，使产品目标用户、核心价值、差异化竞争点等信息达成一致，避免产品偏离方向。
在建模之前，项目团队要思考这样两点：
 用户中台到底能够做什么？ 它的业务范围、目标用户、核心价值和愿景，与其它同类产品的差异和优势在哪里？  2. 业务场景分析 场景分析是从用户视角出发的，根据业务流程或用户旅程，采用用例和场景分析，探索领域中的典型场景，找出领域事件、实体和命令等领域对象，支撑领域建模。事件风暴参与者要尽可能地遍历所有业务细节，充分发表意见，不要遗漏业务要点。
场景分析时会产生很多的命令和领域事件。我用蓝色来表示命令，用橙色表示领域事件，用黄色表示补充信息，比如用户信息数据来源于 HR 系统的说明。
3. 领域建模 领域建模时，我们会根据场景分析过程中产生的领域对象，比如命令、事件等之间关系，找出产生命令的实体，分析实体之间的依赖关系组成聚合，为聚合划定限界上下文，建立领域模型以及模型之间的依赖。领域模型利用限界上下文向上可以指导微服务设计，通过聚合向下可以指导聚合根、实体和值对象的设计
第一步：从命令和事件中提取产生这些行为的实体。用绿色贴纸表示实体。通过分析用户中台的命令和事件等行为数据，提取了产生这些行为的用户、账户、认证票据、系统、菜单、岗位和用户日志七个实体。
第二步：根据聚合根的管理性质从七个实体中找出聚合根，比如，用户管理用户相关实体以及值对象，系统可以管理与系统相关的菜单等实体等，可以找出用户和系统等聚合根。然后根据业务依赖和业务内聚原则，将聚合根以及它关联的实体和值对象组合为聚合，比如系统和菜单实体可以组合为“系统功能”聚合。按照上述方法，用户中台就有了系统功能、岗位、用户信息、用户日志、账户和认证票据六个聚合。
第三步：划定限界上下文，根据上下文语义将聚合归类。根据用户域的上下文语境，用户基本信息和用户日志信息这两个聚合共同构成用户信息域，分别管理用户基本信息、用户登录和操作日志。认证票据和账户这两个聚合共同构成认证域，分别实现不同方式的登录和认证。系统功能和岗位这两个聚合共同构成权限域，分别实现系统和菜单管理以及系统的岗位配置。根据业务边界，我们可以将用户中台划分为三个限界上下文：用户信息、认证和权限。
4. 微服务拆分与设计 原则上一个领域模型就可以设计为一个微服务，但由于领域建模时只考虑了业务因素，没有考虑微服务落地时的技术、团队以及运行环境等非业务因素，因此在微服务拆分与设计时，我们不能简单地将领域模型作为拆分微服务的唯一标准，它只能作为微服务拆分的一个重要依据。
微服务的设计还需要考虑服务的粒度、分层、边界划分、依赖关系和集成关系。除了考虑业务职责单一外，我们还需要考虑将敏态与稳态业务的分离、非功能性需求（如弹性伸缩要求、安全性等要求）、团队组织和沟通效率、软件包大小以及技术异构等非业务因素。
代码模型 没有一个统一的代码模型。
微服务目录架构 按照 DDD 分层架构的分层职责来定义，分别为用户接口层、应用层、领域层和基础层。</description>
    </item>
    
    <item>
      <title>DDD进阶-笔记篇</title>
      <link>https://stong1994.github.io/internet/ddd/advance/</link>
      <pubDate>Fri, 29 Jan 2021 23:31:51 +0800</pubDate>
      
      <guid>https://stong1994.github.io/internet/ddd/advance/</guid>
      <description>领域事件 如何识别领域事件 很简单，和刚才讲的定义是强关联的。在做用户旅程或者场景分析时，我们要捕捉业务、需求人员或领域专家口中的关键词：“如果</description>
    </item>
    
    <item>
      <title>DDD基础-笔记篇</title>
      <link>https://stong1994.github.io/internet/ddd/base/</link>
      <pubDate>Fri, 29 Jan 2021 23:07:51 +0800</pubDate>
      
      <guid>https://stong1994.github.io/internet/ddd/base/</guid>
      <description>中台面临的问题：作为中台，需要将通用的可复用的业务能力沉淀到中台业务模型，实现企业级能力复用。因此中台面临的首要问题就是中台领域模型的重构。而中台落地时，依然会面临微服务设计和拆分的问题。
基础 组织架构演进
DDD解决的问题 DDD 核心思想是通过领域驱动设计方法定义领域模型，从而确定业务和应用边界，保证业务模型与代码模型的一致性。
DDD 强调领域模型和微服务设计的一体性，先有领域模型然后才有微服务，而不是脱离领域模型来谈微服务设计。
其次，就是通过战略设计，建立领域模型，划分微服务边界。
最后，通过战术设计，我们会从领域模型转向微服务设计和落地。
战略设计 战略设计主要从业务视角出发，建立业务领域模型，划分领域边界，建立通用语言的限界上下文，限界上下文可以作为微服务设计的参考边界。
三步来划定领域模型和微服务的边界  在事件风暴中梳理业务过程中的用户操作、事件以及外部依赖关系等，根据这些要素梳理出领域实体等领域对象。 根据领域实体之间的业务关联性，将业务紧密相关的实体进行组合形成聚合，同时确定聚合中的聚合根、值对象和实体。在这个图里，聚合之间的边界是第一层边界，它们在同一个微服务实例中运行，这个边界是逻辑边界，所以用虚线表示。 根据业务及语义边界等因素，将一个或者多个聚合划定在一个限界上下文内，形成领域模型。在这个图里，限界上下文之间的边界是第二层边界，这一层边界可能就是未来微服务的边界，不同限界上下文内的领域逻辑被隔离在不同的微服务实例中运行，物理上相互隔离，所以是物理边界，边界之间用实线来表示。  战术设计 战术设计则从技术视角出发，侧重于领域模型的技术实现，完成软件开发和落地，包括：聚合根、实体、值对象、领域服务、应用服务和资源库等代码逻辑的设计和实现。
基本概念   头脑风暴: DDD 领域建模通常采用事件风暴，它通常采用用例分析、场景分析和用户旅程分析等方法，通过头脑风暴列出所有可能的业务行为和事件，然后找出产生这些行为的领域对象，并梳理领域对象之间的关系，找出聚合根，找出与聚合根业务紧密关联的实体和值对象，再将聚合根、实体和值对象组合，构建聚合。
  领域：在研究和解决业务问题时，DDD 会按照一定的规则将业务领域进行细分，当领域细分到一定的程度后，DDD 会将问题范围限定在特定的边界内，在这个边界内建立领域模型，进而用代码实现该领域模型，解决相应的业务问题。简言之，DDD 的领域就是这个边界内要解决的业务问题域。
  子领域：我们把划分出来的多个子领域称为子域，每个子域对应一个更小的问题域或更小的业务范围。
  核心域：决定产品和公司核心竞争力的子域是核心域，它是业务成功的主要因素和公司的核心竞争力。
  通用域：没有太多个性化的诉求，同时被多个子域使用的通用功能子域是通用域。
  支撑域：既不包含决定产品和公司核心竞争力的功能，也不包含通用功能的功能子域。
  通用语言：在事件风暴过程中，通过团队交流达成共识的，能够简单、清晰、准确描述业务涵义和规则的语言就是通用语言。
 通用语言包含术语和用例场景，并且能够直接反映在代码中。通用语言中的名词可以给领域对象命名，如商品、订单等，对应实体对象；而动词则表示一个动作或事件，如商品已下单、订单已付款等，对应领域事件或者命令。
   上下文边界：用来确定语义所在的领域边界。一个上下文边界理论上就可以设计为一个微服务。
  实体：在 DDD 中有这样一类对象，它们拥有唯一标识符，且标识符在历经各种状态变更后仍能保持一致。对这些对象而言，重要的不是其属性，而是其延续性和标识，对象的延续性和标识会跨越甚至超出软件的生命周期。我们把这样的对象称为实体。
  值对象：通过对象属性值来识别的对象，它将多个相关属性组合为一个概念整体。在 DDD 中用来描述领域的特定方面，并且是一个没有标识符的对象，叫作值对象。在领域建模的过程中，值对象可以保证属性归类的清晰和概念的完整性，避免属性零碎。将“省、市、县和街道等属性”拿出来构成一个“地址属性集合”，这个集合就是值对象了
  聚合：聚合就是由业务和逻辑紧密关联的实体和值对象组合而成的，聚合是数据修改和持久化的基本单元，每一个聚合对应一个仓储，实现数据的持久化。
  聚合根：聚合根的主要目的是为了避免由于复杂数据模型缺少统一的业务规则控制，而导致聚合、实体之间数据不一致性的问题。
 如果把聚合比作组织，那聚合根就是这个组织的负责人。聚合根也称为根实体，它不仅是实体，还是聚合的管理者。</description>
    </item>
    
  </channel>
</rss>
